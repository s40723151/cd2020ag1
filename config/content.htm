<h1>About</h1>
<p>此內容管理系統以 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作.</p>
<h4>利用 cmsimde 建立靜態網誌方法:</h4>
<p>1. 在 github 建立倉儲, git clone 到近端</p>
<p>2. 參考 <a href="https://github.com/mdecourse/newcms">https://github.com/mdecourse/newcms</a>, 加入除了 cmsimde 目錄外的所有內容</p>
<p>以 git submodule add <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> cmsimde</p>
<p>建立 cmsimde 目錄, 並從 github 取下子模組內容.</p>
<p>3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器.</p>
<p>動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端.</p>
<p>4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行:</p>
<p>git clone --recurse-submodules <a href="https://github.com/mdecourse/newcms.git">https://github.com/mdecourse/newcms.git</a></p>
<p><strong></strong></p>
<h2>組員名單</h2>
<p>40723104   <a href="https://s40723104.github.io/cd2020/content/index.html">https://s40723104.github.io/cd2020/content/index.html</a><br/><span><span>40723107</span></span>   <a href="https://s40723107.github.io/cd2020/content/index.html">https://s40723107.github.io/cd2020/content/index.html</a><br/><span><span>40723114</span></span><span> </span><span>(group leader)  <a href="https://s40723114.github.io/cd2020/content/index.html">https://s40723114.github.io/cd2020/content/index.html</a></span><br/><span><span>40723115</span></span>   <a href="https://s40723115.github.io/cd2020/content/index.html">https://s40723115.github.io/cd2020/content/index.html</a><br/><span><span>40723118</span></span>  <a href="https://s40723118.github.io/cd2020/content/index.html">https://s40723118.github.io/cd2020/content/index.html</a><br/><span><span>40723122 </span></span> <a href="https://s40723122.github.io/cd2020/content/index.html">https://s40723122.github.io/cd2020/content/index.html</a><br/>40723123  <a href="https://s40723123.github.io/cd2020/content/index.html">https://s40723123.github.io/cd2020/content/index.html</a><br/>40723140  <a href="https://s40723140.github.io/cd2020/content/index.html">https://s40723140.github.io/cd2020/content/index.html</a><br/><span><span>40723149</span></span>  <a href="https://s40723149.github.io/cd2020/content/index.html">https://s40723149.github.io/cd2020/content/index.html</a><br/>40723151  <a href="https://s40723151.github.io/cd2020/content/index.html">https://s40723151.github.io/cd2020/content/index.html</a><br/><span><span>40723153</span></span>  <a href="https://s40723153.github.io/cd2020">https://s40723153.github.io/cd2020</a><br/><span><span>40723154</span></span>  <a href="https://s40723154.github.io/cd2020/content/index.html">https://s40723154.github.io/cd2020/content/index.html</a><br/><span mce-data-marked="1"><span mce-data-marked="1">40723155</span></span>  <a href="https://s40723155.github.io/cd2020/content/index.html">https://s40723155.github.io/cd2020/content/index.html</a></p>
<p><strong></strong></p>
<h1>直播每周影片與進度</h1><h2>w2</h2>
<p></p>
<p><br/><strong><span style="background-color: #ffffff; color: #000000;">分配工作流程表</span></strong></p>
<p><img alt="" height="378" src="/images/w2分配工作流程表.jpg" width="379"/></p>
<p></p>
<p><strong>w2會議影片</strong></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/JXUKf0cfJcc" width="560"></iframe></p>
<h2>w3</h2>
<p></p>
<p>會議影片</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/QTfPD5bpeKc" width="560"></iframe></p>
<p>會議內容</p>
<p>主要講解python亂數分組程式,以及跟各個細分組長說明接下來必須同時對小組網站進行協同,小組長必須以pull request的方式將改版網站給組長,組長在選擇merge,解決可能合併會產生的問題</p>
<h2>w5</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/ElNea4b1dX8" width="560"></iframe></p>
<p><strong>開會內容</strong></p>
<p><img alt="" height="230" src="/images/擷取.JPG" width="1209"/></p>
<p><b>webots tutorial分配</b></p>
<p><b><img alt="" height="463" src="/images/webots tutorial.JPG" width="845"/></b></p>
<p><strong>主要核心</strong></p>
<p>希望大家能夠摸熟coppelias及webots,並且練習onshape繪圖,充分利用onshape之好處,對於協同者是相當有利的一件事!</p>
<h2>w6</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/B6jt5OAf424" width="560"></iframe></p>
<p><strong>開會內容</strong></p>
<p>1.webots tutorial分配到的趕快完成<br/>2.每個人都須安裝OBS,之後拍影片右下角要有自己的頭像<br/>3.請大家這段時間自行學習Coppeliasim,之後要用這套軟體模擬<br/>4.請安裝pyslvs,並且學習這套軟體,之後要在四輪車上加上提球機構<br/>,需要彼此討論機構設計,去進行模擬<br/>5.TOP0及TOP1的文章,記得有時間可以去看一下<br/>6.Handout meet線上上課說明</p>
<p><strong>開會核心</strong></p>
<p>1.希望大家摸熟coppeliasim這套物理引擎模擬軟體,目前希望能讓車子加上馬達運動,往後加上python編成程式控制,控制四輪車的運動路徑,並且模擬物理環境</p>
<p>2.也請大家安裝pyslvs這套軟體,並且了解這套軟體的操作,對於往後在四輪車上加上提球機構設計,有更大的幫助.</p>
<h3>課程內容</h3>
<p><strong>1.需安裝OBSPortable.exe與yotube做配合,往後拍影片,頭像左下角需要有自己的影像</strong></p>
<p><strong>2.安裝pyslvs.exe,進行四連趕模擬,觀察連桿運動路徑</strong></p>
<p><strong><img alt="" height="906" src="/images/連趕模擬.JPG" width="1610"/></strong></p>
<h2>w7</h2>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/958HX03aAf8" width="560"></iframe></p>
<p><strong>開會內容:</strong></p>
<p>1.分配四輪車零件繪製</p>
<p>2.每個人需要拍一部有關於coppeliasim的tutorial</p>
<p>3.請大家了解Remote API</p>
<p>4.示範如何簡單加馬達使四輪車會動</p>
<p>補充問題:</p>
<p>第一次試用MEET開會,用shareX側錄發現無法錄音</p>
<p>解決辦法:</p>
<p>進入Take Setting - 點選screen recorder - 點選screen recording options -</p>
<p>將Ardio source 選自自己電腦的麥克風</p>
<p><img alt="" height="46" src="/images/進入TAKE SETTING.JPG" width="258"/></p>
<p></p>
<p><img alt="" height="327" src="/images/screen recording.JPG" width="186"/></p>
<p></p>
<p><img alt="" height="283" src="/images/option.JPG" width="775"/></p>
<p></p>
<p><img alt="" height="95" src="/images/麥克風.JPG" width="766"/></p>
<p></p>
<h3>說明線上課程及流程</h3>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/96y-KSUWDyE" width="560"></iframe></p>
<p><strong>開會內容</strong></p>
<p><strong>1.說明線上課程<br/>2.每組的組員一定要會使用obs+youtube,將影片URL遷入個人網站及分組網站<br/>3.每組的組員一定都要跟組長一起與老師用Handout Meet參加會議,並且了解分配的任務,然後組長在另外開會議進行任務分配,並且說明該週目標</strong></p>
<p></p>
<p></p>
<h3>嘗試在coppeliasim上驅動馬達</h3>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/ApUJxR2osl0" width="560"></iframe></p>
<p><strong>核心主旨:</strong></p>
<p><span>主要是驅動馬達,使四輪車能動起來,並且了解各個參數設定</span></p>
<p><strong>馬達參數設定:</strong></p>
<p>1.打開show dynamic properties dialog<span>2.將馬達打開並且設定轉速</span></p>
<p><span><img alt="" height="567" src="/images/打開show dynamic properties dialog.JPG" width="496"/></span></p>
<p><span>2.將馬達打開並且設定轉速</span></p>
<p><span><img alt="" height="190" src="/images/將馬達打開並且設定轉速.JPG" width="428"/></span></p>
<p><span>3.再來點主體,進行物體碰撞設定,三個都要勾起來,才能正常操作</span></p>
<p><img alt="" height="545" src="/images/物體碰撞設定.JPG" width="475"/></p>
<p><span>4.再來將輪子拉在對應的馬達下,再將馬達拉至主題內</span></p>
<p><img alt="" height="274" src="/images/將輪子拉在對應馬達下.JPG" width="285"/></p>
<h2>w8</h2>
<p><strong>在進行remoteAPI時,需安裝三個模組</strong></p>
<p>1.pip install opencv-python</p>
<p>2.pip install imutils</p>
<p>3.pip install numpy</p><h2>w9</h2>
<p><span style="color: #ff6600;"><strong>協同產品設計課程實習項目</strong></span></p>
<p><strong>1.Onshape零組件繪圖與設定</strong></p>
<p><strong>2.<span>零組件轉檔進入 CoppeliaSim</span></strong></p>
<p><strong>(1)轉檔格式有幾個版本需了解</strong></p>
<p><strong>(2)用哪一個格式版本轉檔</strong></p>
<p><strong>3.<span>CoppeliaSim 零組件轉入後之零件分割, 零件從屬關係組立與控制設定</span></strong></p>
<p><strong>4.<span>利用 CoppeliaSim Python Remote API 控制四輪車</span></strong></p>
<p><strong>5.<span>將 Remote API 程式結合 Flask + Oauth2 + SQLite 進行 網際機電控制程式開發</span></strong></p>
<p><strong><span>(1)把現有已經會的東西,放進網際網頁裡,成為一種服務</span></strong></p>
<p><strong><span>(2)管理誰可以在遠端控制我的四輪車</span></strong></p>
<p><strong><span>6.利用 Ubuntu 20.04 虛擬主機, 進行網際協同機電系統操控模擬</span></strong></p>
<p><strong><span>(1) 了解 NAT ,讓虛擬主機可以上網,做內外IP的轉換</span></strong></p>
<p><strong><span>(2)了解 Brid ged Adapter ,可建立獨立service,希望藉由兩片網卡,可以對外連線</span></strong></p>
<p><strong><span>(3)了解 Host - only Adapter</span></strong></p>
<p><strong><span>7.協同四輪車與平面機構系統產品整合開發</span></strong></p>
<p><strong><span>開會內容</span></strong></p>
<p><strong></strong></p>
<p><strong><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/opi_PrsUMW4" width="560"></iframe></span></strong></p><h3>分配內容</h3>
<p><strong>1.利用onshape繪製車子(不可過於簡易,要有懸吊系統跟一些複雜度)</strong><br/><strong>(1)了解零件檔案格式及如何轉檔導入coppeliasim</strong><br/><strong>(2)轉檔格式有幾個版本需要了解</strong></p>
<p><strong>協同人員40723104,40723107,40723122,40723140,40723149,40723151,40723153,40723154</strong></p>
<p><strong>2.利用 CoppeliaSim Python Remote API 控制四輪車</strong><br/><strong>(1)了解 Python Remote API程式,並且能夠實際應用,對車子進行遠端遙控</strong></p>
<p><strong>協同人員</strong></p>
<p><strong>40723114,40723115,40723118,40723123,40723155</strong></p>
<p><strong>3.全體人員須了解 Ubuntu 20.04 虛擬主機</strong><br/><strong>(1) 了解 NAT ,讓虛擬主機可以上網,做內外IP的轉換</strong></p>
<p><strong>(2)了解 Brid ged Adapter ,可建立獨立service,希望藉由兩片網卡,可以對外連線</strong></p>
<p><strong>(3)了解 Host - only Adapter</strong></p><h1>Assignment1</h1>
<h2>python更新至3.8.2</h2>
<p>1.進入 <a href="https://www.python.org/downloads/release/python-382/">https://www.python.org/downloads/release/python-382/</a></p>
<p>2.下載<a href="/get_page/python%20%E6%9B%B4%E6%96%B0%E8%87%B33.8.2/Windows%20x86-64%20executable%20installer">Windows x86-64 executable installer</a></p>
<p>3.下載完成後開啟，選擇Customize installation選項</p>
<p><img alt="" height="296" src="/images/1.PNG" width="482"/></p>
<p>4.不要勾選pip選項，接著按下next</p>
<p><img alt="" height="294" src="/images/3.PNG" width="475"/></p>
<p>5.選擇路徑將python安裝至可攜式系統中的Y槽下</p>
<p>6.接著開啟start_mdecourse.bat批次檔</p>
<p>7.將<span>start_mdecourse.bat批次檔中的py373改為安裝python 3.8.2版本的資料夾</span></p>
<p><span>8.將安裝的版本資料夾取名為py382</span></p>
<p><span><img alt="" height="673" src="/images/2.PNG" width="1098"/></span></p>
<p>9.執行stop.bat批次檔後重新啟動start_mdecourse(為了讓檔案重新讀取)<br/><br/></p>
<p>10.輸入get-pip.py，開始安裝pip工具</p>
<p>11.安裝cmsimde所需模組</p>
<p><img alt="" height="21" src="/images/4.PNG" width="563"/></p>
<h2>python 亂數分組</h2>
<p></p>
<p><img alt="" height="419" src="/images/亂數分組程式.JPG" width="846"/></p>
<p>亂數分組名單</p>
<p><img alt="" height="252" src="/images/亂數分組名單.JPG" width="641"/>影片</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/dTUz8iy_ypY" width="560"></iframe></p>
<p>參考資料</p>
<p><a href="https://kk665403.pixnet.net/blog/post/403974404-%5Bpython%5D-python-ramdom%E9%9A%A8%E6%A9%9F%E4%BA%82%E6%95%B8%E7%B0%A1%E6%98%93%E7%94%A8%E6%B3%95?fbclid=IwAR05Kjm0u7LIJWtpdQrwENl1oUDM7uCW2tyVuki-TgGYtXhupVlsu2W52t4">https://kk665403.pixnet.net/blog/post/403974404-%5Bpython%5D-python-ramdom%E9%9A%A8%E6%A9%9F%E4%BA%82%E6%95%B8%E7%B0%A1%E6%98%93%E7%94%A8%E6%B3%95?fbclid=IwAR05Kjm0u7LIJWtpdQrwENl1oUDM7uCW2tyVuki-TgGYtXhupVlsu2W52t4</a></p>
<h2>了解四輪機器人</h2>
<h3>翻譯</h3>
<p>首先翻譯我們覺得比較有實用的內容</p>
<p>可碰撞物體<span>(Collidable objects)</span></p>
<p>可碰撞對像是可以測試互相碰撞的對象，即將記錄碰撞狀態的對象。這並不意味著它們將對碰撞做出響應（即可響應），這有所不同。可碰撞的對象包括：</p>
<p><span> </span>假人</p>
<p>形狀</p>
<p>超頻樹</p>
<p>點雲</p>
<p>由於基於點，因此虛擬對象和點雲只能與<span>OC</span>樹（基於體積）碰撞。</p>
<p>集合也是可碰撞的，因為它們可能包含可碰撞的對象。</p>
<p>可碰撞對象可以分別啟用或禁用其可碰撞屬性（默認情況下，對於非純形狀，<span>OC</span>樹和點雲啟用）。可以在對象的公共屬性中或通過<span>sim.setObjectSpecialProperty API</span>函數進行設置。</p>
<p>此外，可碰撞對象可以根據其相關的模型屬性（如果它們是模型的一部分）被覆蓋其可碰撞屬性。</p>
<p><span> </span></p>
<p>可測對象<span>(Measurable objects)</span></p>
<p>可測量對像是可用於與其他可測量對象進行最小距離計算的對象。它們包括：</p>
<p><span> </span>假人</p>
<p>形狀</p>
<p>超頻樹</p>
<p>點雲</p>
<p>集合也是可測量的，因為它們可能包含可測量的對象。</p>
<p>可測量對象可以分別啟用或禁用其可測量屬性（默認情況下，對於非純形狀，<span>OC</span>樹和點雲啟用）。可以在對象的公共屬性中或通過<span>sim.setObjectSpecialProperty API</span>函數進行設置。</p>
<p>此外，可測量對象可以根據其相關的模型屬性（如果它們是模型的一部分）而覆蓋其可測量屬性。</p>
<p><span> </span></p>
<p>可檢測物體<span>(Detectable objects)</span></p>
<p>可檢測物體是可以被接近傳感器檢測到的物體。它們包括：</p>
<p>假人</p>
<p>形狀</p>
<p>超頻樹</p>
<p>點雲</p>
<p>由於是基於點的虛擬和點雲，因此射線類型或隨機類型的接近傳感器無法檢測到。</p>
<p>可以通過所有接近傳感器，或僅通過特定類型的接近傳感器或接近傳感器的子類別來檢測可檢測到的物體，如下所示：</p>
<p>超聲波接近傳感器</p>
<p>紅外接近傳感器</p>
<p>激光接近傳感器</p>
<p>電感式接近傳感器</p>
<p>電容式接近傳感器</p>
<p>集合也是可檢測的，因為它們可能包含可檢測的對象。</p>
<p>可檢測的對象可以分別啟用或禁用其可檢測屬性，並且對於所有類型的接近傳感器（默認情況下對非純形狀啟用）都啟用此屬性。可以在對象的公共屬性中或通過<span>sim.setObjectSpecialProperty API</span>函數進行設置。</p>
<p>此外，可檢測對象可以根據其相關的模型屬性（如果它們是模型的一部分）被覆蓋其可檢測屬性。</p>
<p><span> </span></p>
<p>可渲染對象<span>(Renderable objects)</span></p>
<p>可渲染對像是視覺傳感器可以看到或檢測到的對象。它們包括：</p>
<p>形狀</p>
<p>路徑（但是必須啟用路徑整形功能）</p>
<p>圖形（僅呈現非靜態<span>3D</span>曲線）</p>
<p>超頻樹</p>
<p>點雲</p>
<p>集合也是可渲染的，因為它們可能包含可渲染的對象。</p>
<p>您可以使可渲染對象僅由特定的視覺傳感器看到可渲染對像還可以分別啟用或禁用其<span>renderable</span>屬性（默認情況下啟用，純圖形除外）。可以在對象的公共屬性中或通過<span>sim.setObjectSpecialProperty API</span>函數進行設置。</p>
<p>此外，可渲染對象可以根據其相關的模型屬性（如果它們是模型的一部分）而使其可渲染屬性被覆蓋。</p>
<p><span> </span></p>
<p>可視對象<span>(Viewable objects)</span></p>
<p>可見對像是可以瀏覽，查看或可以顯示某些圖像內容的對象。它們包括：</p>
<p>攝影機</p>
<p>視覺傳感器</p>
<p>可視對象可以與將顯示其圖像內容的視圖關聯。</p>
<p><span> </span></p>
<p>虛擬功能<span>(Dummy functions)</span></p>
<p>假人是多用途的對象。它們可以具有非常特定的功能，也可以僅用作輔助對象。以下偽函數是常見的：</p>
<p>用作點或參考系統：當您要跟蹤場景中特定點的位置和<span>/</span>或方向時，就是這種情況。虛擬位置可以與形狀頂點的位置匹配，例如，可以精確定位形狀：在頂點編輯模式下，從頂點創建虛擬對象，然後將形狀附加到虛擬對象（使虛擬對象成為父對象））。並且可以通過虛擬對象來操縱<span>/</span>定位形狀，該虛擬對象的位置與所選頂點相同。</p>
<p>用作模型的代理或支持對象：通過將對象標記為模型基礎標誌來定義模型。任何對像都可以作為模型的基礎，但是虛擬對像是該模型的首選對象。</p>
<p>用作標記點：例如，在評估機器人的工作空間時，可以在不同的時間間隔將假人放置在與機器人末端執行器相同的坐標上，最後可以提取所有添加的假人的凸包並顯示。有關更多詳細信息，請參閱凸包計算部分。</p>
<p>用於指定逆運動學計算中的末端執行器和末端執行器目標位置<span>/</span>方向：逆運動學計算模塊處理運動鏈。每個鏈都有一個基礎對象和一個提示對象。尖端對象必須是假人，並且用戶經常將尖端假人定位和定向為與機器人的末端執行器重合。同時，為了以逆運動學模式移動運動鏈，需要機器人末端執行器的目標位置<span>/</span>方向。同樣，將虛擬對像用作目標對象。</p>
<p>用於為動態模擬的機制創建循環閉合約束：有關更多詳細信息，請參考設計動態模擬的部分。</p>
<p>用作路徑跟隨對象：虛擬對像是唯一可以分配留在路徑上（在路徑上自由，自由滑動）或跟隨路徑位置（固定在路徑上，沿著路徑在其當前固有位置固定）的對象。</p>
<p><img alt="" height="135" src="/images/虛擬1.jpg" width="614"/></p>
<p></p>
<p>虛擬屬性<span>(Dummy properties)</span></p>
<p>虛擬屬性是場景對象屬性對話框的一部分，該對話框位於<span>[</span>菜單欄<span>-&gt;</span>工具<span>-&gt;</span>場景對象屬性<span>]</span>。還可以通過雙按場景層次結構中的對像圖標或單按其工具欄按鈕來打開對話框：</p>
<p><img alt="" height="37" src="/images/虛擬2.jpg" width="38"/></p>
<p>在場景對象屬性對話框中，單按“虛擬”按鈕以顯示虛擬對話框（“虛擬”按鈕僅在最後選擇的是虛擬對象時出現）。該對話框顯示最後選擇的虛擬對象的設置和參數。如果選擇了多個假人，則可以將某些參數從最後選擇的假人復製到其他選定的假人（適用於選擇按鈕）：</p>
<p><img alt="" height="419" src="/images/虛擬3.jpg" width="396"/></p>
<p>鏈接的虛擬對象：鏈接到此對象的虛擬對象。鏈接的虛擬對象（在場景和場景層次中，通過鏈接它們的彩色段很容易識別）具有特殊的屬性和行為，有關更多詳細信息，請參閱下一項。</p>
<p>鏈接類型：鏈接類型將指定仿真期間鏈接的虛擬對象的行為。如果指定了“動力學，重疊約束”，則這兩個虛擬實體將嘗試重疊各自的位置<span>/</span>方向以創建動力學迴路閉合約束。如果指定了<span>IK</span>，則指定了刀尖目標，則兩個鏈接的虛擬對象形成了用於反向運動學計算的刀尖目標對。</p>
<p>遵循主路徑的方向（唯一副路徑）：如果選中，則以路徑作為主（唯一副路徑）的虛擬對象將遵循該路徑的最接近貝塞爾曲線點的方向（而不是位置）。 另請參閱<span>sim.followPath API</span>函數（使用<span>sim.followPath</span>函數，不需要將虛擬對象與路徑作為主從關係）。</p>
<p>遵循主路徑<span>(</span>唯一主路徑<span>)</span>：如果選中該選項，並且假人的主路徑是路徑對象，則假人的位置和方向將由該路徑自動計算（即將從路徑的<span>Bezier</span>點進行插值）。</p>
<p>有兩種選擇：路徑自由或路徑固定。另請參閱<span>sim.followPath API</span>函數（使用<span>sim.followPath</span>函數，不需要將虛擬對象與路徑作為對象）。</p>
<p>路徑上自由：選中該對像後，會將具有路徑對像作為對象的虛擬對象分配為留在路徑上（保持與路徑的<span>Bezier</span>點相同的位置和方向），但可以沿路徑自由移動。它可以通過對像操縱模式沿路徑移動，也可以由逆運動學模塊自動沿路徑引導。</p>
<p>固定在路徑上：選中此選項後，會將具有路徑對像作為對象的虛擬對象分配為留在路徑上（與路徑的<span>Bezier</span>點保持相同的位置和方向），位於路徑的固有位置。一個比喻是在過山車的履帶部分上的貨車（將貨車拉起的初始部分）。在這種情況下，可以指定從路徑位置偏移的距離。</p>
<p>偏移量：將假人分配到路徑上的固定位置時，與路徑位置的距離偏移量。如果要創建履帶，則履帶的第一個墊板（剛性元件）將位於偏移量<span>0</span>處，第二個墊板將位於偏移量<span>x</span>處，第二個墊板將位於偏移量<span>2x</span>處，依此類推。</p>
<p>複製增量：添加到復制的虛擬對象的偏移量上的值（請參見上文）（例如，在創建毛毛蟲時，您可能需要幾十個墊板，每個墊板都可以自動計算出不同的偏移量）。</p>
<p>對像大小：假人的大小。該參數僅具有視覺效果，沒有功能意義。</p>
<p>調整虛擬顏色：允許調整虛擬顏色</p>
<p><span> </span></p>
<p>接近傳感器<span>(Proximity sensors)</span></p>
<p><span>CoppeliaSim</span>提供了一種非常強大而有效的方法來模擬接近傳感器。用戶可以為幾乎所有類型的接近傳感器建模，從超聲波到紅外等等。允許此功能的場景對像是接近傳感器（與視覺傳感器不同），可以檢測可檢測到的實體。下圖說明了使用接近傳感器的仿真：</p>
<p><img alt="" height="228" src="/images/傳感器1.jpg" width="600"/></p>
<p>接近傳感器通過<span>[</span>菜單欄<span>-&gt;</span>添加<span>-&gt;</span>接近傳感器<span>]</span>添加到場景中。</p>
<p>接近傳感器使用的接近傳感器檢測例程也可以通過<span>Coppelia</span>幾何例程作為獨立例程使用。</p>
<p><span> </span></p>
<p>接近傳感器的類型和操作模式<span>(Proximity sensor types and mode of operation)</span></p>
<p>接近傳感器有<span>6</span>種不同類型，可以在很大程度上進行定制：</p>
<p>射線型：射線型接近傳感器非常適合非常簡單的接近傳感器建模或激光測距儀建模。它們是最快的接近傳感器。</p>
<p>隨機射線型：隨機射線型接近傳感器用作隨機掃描圓錐體的射線型傳感器。它的外觀與錐形接近傳感器類似。</p>
<p>金字塔型：金字塔型接近傳感器非常適合對帶有矩形檢測體積的接近傳感器進行簡單建模。他們很快。</p>
<p>圓柱型：圓柱型接近傳感器非常適合對具有旋轉體積的檢測體積的接近傳感器進行簡單建模。他們很快。</p>
<p>圓盤式：圓盤式接近傳感器可對具有旋轉掃描檢測體積的接近傳感器進行精確建模。根據所選的精度和操作模式，它們可能需要更多的計算量。</p>
<p>圓錐型：圓錐型接近傳感器允許對大多數接近傳感器進行最佳，最精確的建模。根據所選的精度和操作模式，它們可能需要更多的計算量。</p>
<p><span> <img alt="" height="141" src="/images/傳感器2.jpg" width="631"/></span></p>
<p>接近傳感器以幾何上精確的方式運行：它們在其感測點（小球體）與任何干擾其檢測體積的可檢測實體之間執行精確的距離計算（像大多數傳感器一樣，它們在傳感體積邊緣之間不執行簡單的碰撞檢測其他模擬軟件，但在檢測範圍內進行精確的距離計算）。每個接近傳感器將計算以下最小距離：</p>
<p><img alt="" height="210" src="/images/傳感器3.jpg" width="612"/></p>
<p>如果接近傳感器檢測到物體，則會激活觸發器，這將導致對觸發器回調函數的調用。</p>
<p>接近傳感器的計算結果可以通過圖形對象記錄。</p>
<p><span> </span></p>
<p>視覺傳感器<span>(Vision sensors)</span></p>
<p>除了接近傳感器之外，<span>CoppeliaSim</span>還提供另一種傳感器：視覺傳感器。視覺傳感器是可見的對象，其操作方式與攝影機對象非常相似：它們將渲染其視場中的對象，並在指定的閾值被過度拍攝或拍攝不足時觸發檢測。可以檢測可渲染實體的視覺傳感器應主要在顏色，光線或結構在檢測過程中起作用的情況下，在接近傳感器上使用（例如，紅外傳感器，或更籠統地說，對光敏感的傳感器（相機等））。但是，根據運行應用程序的圖形卡或場景對象的複雜程度，視覺傳感器可能會比接近傳感器慢一些。下圖說明了使用視覺傳感器的應用：</p>
<p><span> <img alt="" height="179" src="/images/視覺1.jpg" width="600"/></span></p>
<p>確保不要將視覺傳感器與相機混淆。以下是主要區別：</p>
<p>視覺傳感器具有固定的分辨率。相機沒有特定的分辨率（即，它會自動調整為視圖尺寸）。</p>
<p>視覺傳感器的圖像內容可通過<span>API</span>訪問，圖像處理可通過視覺回調函數進行處理。無法通過<span>API</span>直接獲得相機的圖像內容。</p>
<p>視覺傳感器通常比攝像頭需要更多的<span>CPU</span>時間並且運行速度較慢。</p>
<p>視覺傳感器只能顯示可渲染的對象。攝像機可以顯示所有對像類型。</p>
<p><span> </span></p>
<p>視覺傳感器類型和操作模式<span>(Vision sensor types and mode of operation)</span></p>
<p>視覺傳感器分為<span>2</span>種類型，可以針對不同目的進行調整：</p>
<p>正射投影型：正射投影型視覺傳感器的視場為矩形。它們非常適合於近距離紅外傳感器或激光測距儀。</p>
<p>透視投影型：透視投影型視覺傳感器的視場是梯形的。它們非常適合於相機型傳感器。</p>
<p><img alt="" height="176" src="/images/視覺2.jpg" width="393"/></p>
<p>視覺傳感器是可見的對象，可以像相機對像一樣進行瀏覽<span>[</span>彈出菜單<span>-&gt;</span>視圖<span>-&gt;</span>將視圖與選定的視覺傳感器相關聯<span>]</span>。有關更多詳細信息，另請參見頁面和視圖部分。</p>
<p><span> <img alt="" height="311" src="/images/視覺3.jpg" width="487"/></span></p>
<p>視覺傳感器功能強大，可以以多種靈活方式使用。例如，它們可以用於顯示來自外部應用程序或插件的靜止或運動圖像。插件還可以提供定制的圖像處理算法以及評估算法（例如觸發條件）。視覺回調函數代表了可以進行圖像處理以及可以生成觸發器的機制（可以對觸發器回調函數中的觸發器做出反應）。</p>
<p>視覺傳感器只能渲染（和檢測）可渲染的實體。</p>
<p>力傳感器<span>(Force sensors)</span></p>
<p>力傳感器最初是兩個形狀之間的剛性鏈接，能夠測量傳遞的力和扭矩。力傳感器的剛性是有條件的，在某種意義上，如果出現某種條件（例如，如果力或扭矩閾值被超過），則力傳感器可能會損壞。</p>
<p><span> <img alt="" height="252" src="/images/力1.jpg" width="477"/></span></p>
<p>力傳感器測量三個<span>3</span>對值，分別代表沿<span>x</span>，<span>y</span>和<span>z</span>軸施加在傳感器上的力以及圍繞<span>x</span>，<span>y</span>和<span>z</span>軸施加在傳感器上的扭矩：</p>
<p><img alt="" height="194" src="/images/力2.jpg" width="267"/></p>
<p>最初，力傳感器充當剛性連接。然而，在模擬過程中，當超過指定的力<span>/</span>扭矩閾值或滿足某些其他用戶定義的條件時，力傳感器可能會損壞。下圖說明了力傳感器的損壞狀態：</p>
<p><span> <img alt="" height="222" src="/images/力3.jpg" width="478"/></span></p>
<p>如果動態啟用了力傳感器，則它只能在仿真期間運行。 有關動態啟用的力傳感器的更多信息，另請參閱有關設計動態仿真的部分。 關節也能夠測量力或扭矩，但是只能沿/繞其z軸測量。</p>
<p>力傳感器通過[菜單欄-&gt;添加-&gt;力傳感器]添加到場景中。</p>
<p></p>
<p>路徑<span>(Paths)</span></p>
<p>路徑是定義空間中的路徑或軌蹟的對象。它可以用於各種任務，如下圖所示：</p>
<p><span> <img alt="" height="328" src="/images/路徑1.jpg" width="600"/></span></p>
<p>可以使用<span>[</span>菜單欄<span>-&gt;</span>添加<span>-&gt;</span>路徑<span>]</span>將路徑對象添加到場景中。默認情況下，有兩個基本路徑可用：簡單的段類型路徑或圓形類型路徑。它們可以定向或縮放，但是通常這還不夠。用戶可以使用幾種方法來生成定制的路徑對象：</p>
<p>從文件導入路徑。</p>
<p>編輯路徑。</p>
<p>從形狀的邊緣生成路徑。有關詳細信息，請參見邊緣編輯模式。</p>
<p>路徑本身並沒有多大作用。它們通常與假人和其他物體結合使用以獲得所需的效果。要沿路徑移動對象，首先需要將虛擬對象分配給路徑，然後可以將對象附著到虛擬對象，該對象將遵循路徑的固有移動。有關更多詳細信息，請參閱關於虛擬變量的部分。</p>
<p>路徑是可渲染的對象，這意味著視覺傳感器可以看到路徑。但是，需要啟用路徑整形功能。可以在對象公共屬性中更改路徑的可渲染屬性。</p>
<p>某些路徑數據可以由圖形對象記錄。</p>
<p></p>
<p>路徑控制點和貝塞爾曲線點<span>(Control points and Bezier points)</span></p>
<p>路徑具有位置和方向分量（或通道），還可以另外具有描述速度曲線的分量。路徑由控制點定義，這些控制點將路徑描述為一系列鏈接的段。僅當選擇路徑時，控制點才可見：</p>
<p><span><img alt="" height="107" src="/images/路徑2.jpg" width="595"/><br/></span></p>
<p>路徑的第一個控制點（起點）表示為球體，其餘的控制點表示為立方體。路徑可以是開放的或封閉的。當關閉時，它變成循環的。</p>
<p><img alt="" height="102" src="/images/路徑3.jpg" width="292"/></p>
<p>每個控制點都具有可以更詳細地描述路徑的屬性：每個控制點都可以描述是否以及如何計算貝塞爾曲線。</p>
<p><span><img alt="" height="134" src="/images/路徑4.jpg" width="600"/><br/></span></p>
<p>默認情況下，貝塞爾曲線點始終可見（即使未選擇對象時），並顯示為紅色，綠色和藍色的小箭頭，指示貝塞爾曲線點的<span>x</span>軸，<span>y</span>軸和<span>z</span>軸（實際上是取向）。貝塞爾曲線部分由<span>3</span>個參數描述</p>
<p><span> <img alt="" height="170" src="/images/路徑5.jpg" width="419"/></span></p>
<p><span>Bezier</span>插值因子指示<span>Bezier</span>曲線部分的起點和終點，而<span>Bezier</span>點數指示曲線的詳細程度（或平滑度）。<span> Bezier</span>點計數為<span>1</span>在技術上禁用了<span>Bezier</span>曲線插值機制，但為簡單起見，該控制點被稱為<span>Bezier</span>點。</p>
<p>可以在路徑編輯模式下手動調整控制點的位置和方向。但是不能單獨調整<span>Bezier</span>點的方向。它是自動計算的。默認情況下，貝塞爾曲線點的方向將遵循路徑曲率（如果啟用了自動方向選項），否則它們將與控制點的方向進行插值</p>
<p><span> <img alt="" height="170" src="/images/路徑6.jpg" width="419"/></span></p>
<p><span> </span></p>
<p>路徑位置和長度計算方法<span>(Path position and length calculation methods)</span></p>
<p>沿著路徑對象，可以定義固有位置。該位置（也稱為路徑位置）與路徑對象的位置不同。雖然路徑對象的位置是路徑對象原點的位置（在選擇路徑時顯示為白色線框立方體），但是路徑位置或固有路徑位置是沿路徑的位置值</p>
<p><span><img alt="" height="179" src="/images/路徑7.jpg" width="429"/> </span></p>
<p>路徑的<span>Bezier</span>點可以是不同的，也可以是重合的：想像一個焊接機器人，其末端執行器是焊接設備的尖端；在兩個連續的<span>Bezier</span>點之間，末端執行器可以：<span> </span></p>
<p>在不改變方向的情況下執行平移（即沿著直線）（兩個<span>Bezier</span>點是不同的，但方向相同）。</p>
<p>執行平移並更改方向（兩個<span>Bezier</span>點是不同的，並且方向不同）。</p>
<p>在不改變位置的情況下執行旋轉（即更改方向）（兩個<span>Bezier</span>點重合但方向不同）。</p>
<p>此外，在某些情況下，我們希望焊炬遵循預定的路徑，在某個特定位置暫停（例如，處理較大的焊接點），然後沿該路徑繼續前進。為了正確處理上述<span>3</span>種情況和特殊的暫停情況，重要的是能夠唯一地識別沿路徑（即路徑位置<span>*</span>）的任何位置<span>*</span>（廣義上的位置）以及路徑長度<span>*</span>（從更廣泛的意義上講是長度）。為此，用戶可以選擇幾種位置計算方法：</p>
<p><span> </span></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積線性變化。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="/images/公式1.jpg" width="92"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積角度<span>**</span>變化。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="/images/公式2.jpg" width="107"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積（線性變化<span>+</span>角度<span>**</span>變化）。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="/images/公式3.jpg" width="139"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積最大值（線性變化，角度<span>**</span>變化）。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="/images/公式4.jpg" width="169"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積（線性變化，如果不為零，否則為角度<span>**</span>）。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="/images/公式5.jpg" width="328"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的累積（角度<span>**</span>變化，如果不為零，否則為線性變化）。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="/images/公式6.jpg" width="347"/></p>
<p>路徑位置<span>*</span>被描述為沿路徑的（線性變化，角度<span>**</span>變化）的累積歐幾里德距離。路徑長度<span>*</span>由下式給出：<img alt="" height="24" src="/images/公式7.jpg" width="145"/></p>
<p><span> </span></p>
<p>其中Δ<span>l</span>和Δα分別是兩個連續的<span>Bezier</span>點之間的線性和角度變化。角度<span>**</span>變化是規則角度變化乘以角度係數<span>c</span>。<span> c</span>稱為角度到線性的轉換係數，並且可以將角度值和線性值組合在一起。這意味著沿路徑的位置<span>*</span>或路徑長度<span>*</span>始終以線性單位（例如米）給出，而與上面選擇的位置計算方法無關。</p>
<p>默認情況下，紅色標記的項為零。該術語可以看作是<span>Bezier</span>點（或路徑控制點）的虛擬距離或第四坐標（即每個<span>Bezier</span>點將由方向和位置（<span>x</span>，<span>y</span>，<span>z</span>，<span>w</span>）定義，其中<span>w</span>是第四坐標）。這對於沿路徑歸檔暫停點很有用。是兩個連續的<span>Bezier</span>點之間的虛擬距離變化。<span> d</span>是虛擬距離變化的比例因子（例如，如果<span>d</span>加倍，則所有暫停點的暫停持續時間將是兩倍）。為簡化起見，在以下內容中我們將不再提及該術語並將其設為零。</p>
<p>以下示例闡明了位置和長度計算概念：</p>
<p><span> <img alt="" height="256" src="/images/路徑8.jpg" width="600"/></span></p>
<p><img alt="" height="220" src="/images/路徑9.jpg" width="450"/></p>
<p></p>
<p><img alt="" height="205" src="/images/路徑10.jpg" width="600"/></p>
<p><img alt="" height="192" src="/images/路徑11.jpg" width="450"/></p>
<p>要歸檔沿路徑的特定點處的運動暫停，請執行以下操作：創建<span>3</span>個相同的路徑控制點（位置和方向完全重合），並為中間控制點指定一個虛擬距離值，該值不得為零。在下面的示例中，在<span>3</span>個重合點的虛擬距離為<span>2</span>（在第一和中間重合控制點之間為<span>1</span>，在中間和第三重合控制點之間為<span>1</span>）。如果某個對像以每秒<span>1</span>米的速度沿路徑行進，則它將在重合的控制點處記錄<span>2</span>秒的暫停：</p>
<p><span> <img alt="" height="213" src="/images/路徑12.jpg" width="285"/></span></p>
<p><span> </span></p>
<p>沿路徑運動<span>(Movement along a Path)</span></p>
<p>當前固有路徑位置在路徑上顯示為紅色球形（如果啟用了路徑位置顯示）。在模擬過程中，可以隨時使用<span>sim.setPathPosition</span>來控制球沿路徑的位置。確保了解如何計算路徑位置或路徑長度。</p>
<p>要實際使對象沿路徑移動，首先需要將對象附加到虛擬對象，然後分配虛擬對像以遵循路徑位置（帶有可選的偏移量）。</p>
<p><span> </span></p>
<p>導入和導出路徑<span>(Importing and exporting paths)</span></p>
<p>路徑導入<span>/</span>導出功能可在<span>CSV</span>文件（逗號分隔值）上運行，該<span>CSV</span>文件可以用簡單的文本編輯器創建或讀取，但也可以輕鬆地導入<span>/</span>導出到<span>Microsoft Excel</span>等應用程序中。</p>
<p>導入路徑</p>
<p><span>CoppeliaSim</span>的導入功能（<span>[</span>菜單欄<span>-&gt;</span>文件<span>-&gt;</span>導入<span>-&gt; CSV</span>的路徑<span>...]</span>）逐行讀取值，其中每行對應一個控制點。每行應採用以下格式設置：</p>
<p><span> </span><span>x</span>，<span>y</span>，<span>z</span>，<span>alpha</span>，<span>beta</span>，<span>gamma</span>，<span>relativeVelocity</span>，<span>BezierPointCount</span>，<span>interpolationFactor1</span>，<span>interpolationFactor2</span>，</p>
<p><span> virtualDistance</span>，<span>auxiliaryFlags</span>，<span>auxiliaryChannel1</span>，<span>auxiliaryChannel2</span>，<span>auxiliaryChannel3</span>，<span>auxiliaryChannel4</span></p>
<p>其中內容相對應的意思：<span> </span></p>
<p>（<span>x</span>，<span>y</span>，<span>z</span>）表示控制點在<span>METERS</span>中的位置</p>
<p>（α，β，γ）表示控制點的方向，以度數表示為歐拉角。默認值為（<span>0,0,0</span>）。</p>
<p>相對速度已棄用。設為<span>1.0</span></p>
<p><span>BezierPointCount</span>是控制點所需的<span>Bezier</span>點數。默認值為<span>1</span>。</p>
<p><span>InterpolationFactor1</span>和<span>InterpolationFactor2</span>是在路徑控制點和<span>Bezier</span>點部分中描述的插值因子。默認值為<span>0.5</span></p>
<p><span>VirtualDistance</span>：虛擬距離值，添加到該控制點位置的路徑長度上，另請參見路徑位置或路徑長度計算方法。默認值為<span>0.0</span></p>
<p>輔助標誌：可以用於各種目的的標誌，可以通過<span>sim.getDataOnPath</span>函數進行查詢。默認值為<span>0</span>。</p>
<p>輔助通道<span>1-4</span>：可以用於各種目的的值，可以通過<span>sim.getDataOnPath</span>函數進行查詢。默認值為<span>0.0</span></p>
<p>除了前三個值（控制點位置坐標）外，所有其他值都可以省略，在這種情況下，將應用默認值。</p>
<p><span> </span>導出路徑</p>
<p>通過選擇路徑，然後單擊<span>[</span>菜單欄<span>-&gt;</span>文件<span>-&gt;</span>導出<span>-&gt;</span>選定路徑為<span>CSV ...]</span>，可以導出路徑的控制點。在這種情況下，導出格式與前面描述的路徑導入格式相同。</p>
<p>也可以通過選擇路徑，然後單擊<span>[</span>菜單欄<span>-&gt;</span>文件<span>-&gt;</span>導出<span>-&gt;</span>所選路徑的<span>Bezier</span>曲線為<span>CSV ...]</span>來導出路徑的<span>Bezier</span>點。在這種情況下，創建的文件（導出的文件）中的每一行都對應一個<span>Bezier</span>點，並包含以下值：</p>
<p><span> </span><span>x</span>，<span>y</span>，<span>z</span>，<span>alpha</span>，<span>beta</span>，<span>gamma</span>，相對速度，虛擬距離，輔助標記，輔助通道<span>1</span>，輔助通道<span>2</span>，<span>assistantChannel3</span>，<span>auxiliaryChannel4</span><span> </span></p>
<p><span> </span></p>
<p>路徑編輯模式<span>(Path edit mode)</span></p>
<p>初步說明：路徑編輯模式是一種方便且功能齊全的編輯路徑對象的方法。但是，可以在不進入用於最小化路徑修改的路徑編輯模式的情況下移動和擦除單個路徑點（選擇單個路徑點時，請確保沒有選擇除路徑之外的其他對象）。</p>
<p>可以通過單擊相應的工具欄按鈕來訪問路徑編輯模式：</p>
<p><span><img alt="" height="37" src="/images/路徑編輯一.jpg" width="38"/><br/></span></p>
<p><span>[</span>路徑編輯模式工具欄按鈕<span>]</span><span> </span></p>
<p>上面的工具欄按鈕僅在選擇路徑後才有效。在路徑編輯模式下，窗口中通常顯示場景層次結構的部分用於將路徑控制點顯示為列表。可以使用鼠標選擇列表中的項目，就像在層次結構窗口中的對像一樣。</p>
<p><span> <img alt="" height="478" src="/images/路徑編輯二.jpg" width="600"/></span></p>
<p><span>[</span>路徑編輯模式<span>]</span></p>
<p>現在可以像常規對像一樣選擇單個控制點。最後選擇的控制點以白色顯示，其他選擇的控制點以黃色顯示，未選擇的控制點以藍色顯示。以類似的方式，可以使用鼠標直接平移控制點，方法是使用工具欄的對象<span>/</span>項目平移工具欄按鈕在與視圖方向垂直的平面中平移所選的控制點：</p>
<p><span><img alt="" height="37" src="/images/路徑編輯三.jpg" width="38"/><br/></span></p>
<p><span>[</span>對象<span>/</span>項目翻譯工具欄按鈕<span>]</span></p>
<p>在路徑編輯模式下，將顯示路徑編輯模式對話框：</p>
<p><span><img alt="" height="478" src="/images/路徑編輯四.jpg" width="396"/><br/></span></p>
<p><span>[</span>控制點屬性對話框<span>]</span></p>
<p>路徑已關閉：如果選中，則路徑的最後一個控制點將鏈接到其第一個控制點，以關閉路徑並使其循環運行。閉合路徑至少需要<span>3</span>個控制點。</p>
<p>路徑是平坦的：如果選中，則所有控制點（以及隨後的所有<span>Bezier</span>點）都將約束到路徑對象的本地參考系的<span>z = 0</span>平面。</p>
<p>自動定向：如果啟用，則將自動計算所有控制點和貝塞爾曲線點的定向，以使該點的<span>z</span>軸沿著路徑，其<span>y</span>軸指向其曲率向外（如果啟用了<span>x up</span>，則<span>y -</span>軸沒有特別限制）。如果禁用，則用戶確定控制點的方向，貝塞爾曲線點的方向將從路徑的控制點的方向內插。</p>
<p>保持<span>x</span>向上：如果選中，則自動定向功能將使每個<span>Bezier</span>點的<span>z</span>軸沿路徑對齊，並使其<span>x</span>軸沿路徑對象的<span>z</span>軸指向。</p>
<p>清除選擇：清除控制點的選擇。</p>
<p>反轉選擇：反轉控制點的選擇狀態。</p>
<p>製作虛擬對象：在選擇控制點的位置生成虛擬對象。</p>
<p>貝塞爾曲線插值因子<span>1/2</span>：有關詳細信息，請參見控制點和貝塞爾曲線部分。</p>
<p>貝塞爾曲線點數：有關詳細信息，請參見控制點和貝塞爾曲線部分。</p>
<p>虛擬距離：有關詳細信息，請參見關於沿路徑運動的部分。</p>
<p>輔助標誌：可以用於各種目的的標誌，可以通過<span>sim.getDataOnPath</span>函數進行查詢。</p>
<p>輔助通道<span>1-4</span>：可以用於各種目的的值，可以通過<span>sim.getDataOnPath</span>函數進行查詢。</p>
<p>為了精確定位控制點，請使用坐標和變換對話框。如果要編輯控制點的方向，請確保禁用路徑的“自動方向”選項（默認情況下啟用該選項）。</p>
<p>常規鍵組合（即<span>ctrl-c</span>，<span>ctrl-v</span>，<span>delete</span>和<span>ctrl-x</span>）支持複製<span>/</span>粘貼<span>/</span>刪除<span>/</span>剪切操作。確保主視圖具有焦點，以便按鍵起作用。如果未選擇任何控制點，則黏貼操作會將復制的控制點黏貼到控制點列表的開頭，否則將黏貼到選定的控制點之後（確保不超過一個控制點）。在此階段選擇）。也可以通過彈出菜單或通過<span>[</span>主菜單<span>-&gt;</span>編輯<span>]</span>訪問相同的複制<span>/</span>黏貼<span>/</span>刪除<span>/</span>剪切功能。其他操作包括：</p>
<p>在路徑的開頭插入新的路徑點<span>/</span>選擇後插入新的路徑點：如果未選擇任何控制點，則在路徑的開頭插入新的控制點；否則，在當前選擇之後插入新的控制點（請確保沒有其他內容）在這種情況下，選擇一個控制點）。</p>
<p>從貝塞爾曲線創建新路徑：使用當前路徑的貝塞爾點生成一個新的路徑對象，即新路徑的控制點將為當前路徑的貝塞爾點。</p>
<p><span> </span></p>
<p>超頻樹<span>(OC trees)</span></p>
<p><span>OC</span>樹是代表空間分區的對象。它由樹形數據結構組成，其中每個節點正好具有八個子代。佔用的葉節點表示為體素。<span> OC</span>樹可用於為形狀或點雲提供簡化的表示，或者可充當佔用網格<span>/</span>空間：</p>
<p><span><img alt="" height="393" src="/images/樹木3.jpg" width="527"/><br/></span></p>
<p><span>OC</span>樹是可碰撞，可測量和可檢測的對象。這意味著<span>OC</span>樹：</p>
<p>可用於與其他可碰撞對象的碰撞檢測。</p>
<p>可與其他可測量對像一起用於最小距離計算。</p>
<p>可以被接近傳感器檢測到。</p>
<p><span>OC</span>樹可以使用<span>[</span>菜單欄<span>-&gt;</span>添加<span>-&gt; OC</span>樹<span>]</span>添加到場景中，並通過<span>OC</span>樹屬性進行編輯。</p>
<p><span>CoppeliaSim</span>中可用的<span>OC</span>樹計算（即碰撞，距離和接近傳感器計算）也可以通過<span>Coppelia</span>幾何例程作為獨立例程使用。</p>
<p><span> </span></p>
<p><span>OC</span>樹屬性<span>(OC tree properties)</span></p>
<p><span>OC</span>樹屬性是場景對象屬性對話框的一部分，該對話框位於<span>[</span>菜單欄<span>-&gt;</span>工具<span>-&gt;</span>場景對象屬性<span>]</span>。您還可以通過雙擊場景層次結構中的對像圖標或單擊其工具欄按鈕來打開對話框：</p>
<p><span> <img alt="" height="37" src="/images/樹木1.jpg" width="38"/></span></p>
<p><span>[</span>場景對象屬性工具欄按鈕<span>]</span></p>
<p>在場景對象屬性對話框中，單擊<span>OC</span>樹按鈕以顯示<span>OC</span>樹對話框（僅當最後選擇的是<span>OC</span>樹時才會顯示<span>OC</span>樹按鈕）。該對話框顯示最後選擇的<span>OC</span>樹的設置和參數：</p>
<p><span> <img alt="" height="342" src="/images/樹木2.jpg" width="380"/></span></p>
<p><span>[OC</span>樹對話框<span>]</span></p>
<p>體素大小：<span>OC</span>樹體素的大小。大小越小，用於<span>OC</span>樹數據結構的內存就越大。</p>
<p>插入選定的可見對象：允許基於選定的可見對象插入體素。僅考慮虛擬對象，形狀，超頻樹和點雲。選擇要插入的所有對象，然後最後選擇目標<span>OC</span>樹對象。</p>
<p>減去選定的可見對象：允許基於選定的可見對象刪除體素。僅考慮虛擬對象，形狀，超頻樹和點雲。選擇要插入的所有對象，然後最後選擇目標<span>OC</span>樹對象。</p>
<p>清除<span>OC</span>樹：從<span>OC</span>樹中刪除所有體素。</p>
<p>體素具有隨機顏色：每個體素將具有隨機顏色。</p>
<p>顯示<span>OC</span>樹結構：顯示<span>OC</span>樹數據結構，主要用於調試目的。</p>
<p>顏色是自發光的：體素將以自發光的顏色顯示。</p>
<p>顯示點而不是體素：對於包含大量體素的<span>OC</span>樹，顯示可能會很慢。在這種情況下，您可以顯示像素體素，而不是立方體素。</p>
<p>調整下一次插入的顏色：允許選擇新的顏色，該顏色將用於新的體素插入。<span><br/> <br/> </span></p>
<p><span></span></p>
<p>點雲<span>(Point clouds)</span></p>
<p>點雲是充當基於<span>OC</span>樹的點容器的對象：</p>
<p><span> <img alt="" height="416" src="/images/雲3.jpg" width="599"/></span></p>
<p>點雲是可碰撞，可測量和可檢測的對象。這意味著點雲：</p>
<p>可用於與其他基於體積的可碰撞對象（例如<span>OC</span>樹）的碰撞檢測。</p>
<p>可與其他可測量對像一起用於最小距離計算。</p>
<p>可以被接近傳感器檢測到。</p>
<p>可以使用<span>[</span>菜單欄<span>-&gt;</span>添加<span>-&gt;</span>點雲<span>]</span>將點雲添加到場景，並通過點雲屬性進行編輯。</p>
<p><span>CoppeliaSim</span>中可用的點雲計算（即碰撞，距離和接近傳感器計算）也可以通過<span>Coppelia</span>幾何例程作為獨立例程使用。</p>
<p><span> </span></p>
<p>點雲屬性<span>(Point cloud properties)</span></p>
<p>點雲屬性是場景對象屬性對話框的一部分，該對話框位於<span>[</span>菜單欄<span>-&gt;</span>工具<span>-&gt;</span>場景對象屬性<span>]</span>。您還可以通過雙擊場景層次結構中的對像圖標或單擊其工具欄按鈕來打開對話框：</p>
<p><span> <img alt="" height="37" src="/images/雲1.jpg" width="38"/></span></p>
<p><span>[</span>場景對象屬性工具欄按鈕<span>]</span></p>
<p>在場景對象屬性對話框中，單擊“點雲”按鈕以顯示<span>OC</span>樹對話框（“點雲”按鈕僅在最後選擇的是點雲時出現）。該對話框顯示最後選擇的點雲的設置和參數：</p>
<p><span> <img alt="" height="413" src="/images/雲2.jpg" width="380"/></span></p>
<p><span>[</span>點雲對話框<span>]</span></p>
<p>不要使用<span>OC</span>樹計算。結構：默認情況下，點雲使用類似於<span>OC</span>樹的計算結構進行有效的點操作。此結構可能會減慢插入點和刪除點的速度。如果啟用此項目，則點插入將更加有效，但是點雲將不再可碰撞，不可測量或不可檢測，並且某些其他操作也可能會受到限制。您始終可以在以後的階段或通過<span>sim.setPointCloudOptions</span>切換此項目。</p>
<p>最高體素大小：將包含點的<span>OC</span>樹體素的最大大小。大小越小，此點雲所基於的<span>OC</span>樹數據結構將使用的內存就越大。</p>
<p>最高點數<span>/</span>體素：單個<span>OC</span>樹體素可以包含的最大點數。如果需要在此類體素中存儲更多點，它將被拆分為<span>8</span>個子體素，直到滿足約束條件為止。為了有效地進行碰撞檢測，距離計算和接近傳感器檢測，建議在單個體素中存儲大約<span>10-20</span>個點。</p>
<p>插入選定的可見對象：允許基於選定的可見對象插入點。僅考慮虛擬對象，形狀，超頻樹和點雲。選擇要插入的所有對象，然後最後選擇目標點雲對象。形狀將事先轉換為具有指定構建分辨率的臨時<span>OC</span>樹。插入公差項允許通過指定用於確定是否插入點的最小距離公差來避免重複的點。插入公差<span>&gt; 0.0</span>時，點插入將變慢。</p>
<p>減去選定的可見對象：允許基於選定的可見對象減去點。僅考慮虛擬變量，超頻樹和點雲。選擇要減去的所有對象，然後最後選擇目標點雲對象。假人和點雲將使用減法公差值來標識要刪除的點。</p>
<p>清除點雲：從點雲中刪除所有點。</p>
<p>點具有隨機顏色：每個點將具有隨機顏色。</p>
<p>顯示<span>OC</span>樹結構：顯示底層<span>OC</span>樹數據結構，主要用於調試目的。</p>
<p>顏色是自發光的：點將以自發光的顏色顯示。</p>
<p>點顯示比例：包含大量點的點雲可能會減慢渲染速度。通過將比率設置為小於<span>1</span>，將為每個包含點的<span>OC</span>樹體素顯示更少的點數。這僅對顯示<span>/</span>渲染的圖像有影響。</p>
<p>點大小：點的大小，以像素為單位。</p>
<p>調整下一次插入的顏色：允許選擇一種新的顏色，該顏色將用於新的點插入。</p>
<p><span> </span></p>
<p>外部控制器教程<span>(External controller tutorial)</span></p>
<p>在<span>CoppeliaSim</span>中，有幾種方法可以控制機器人或仿真：</p>
<p>最方便的方法是編寫一個子腳本來處理給定機器人或模型的行為。這是最方便的方法，因為子腳本直接附加到場景對象，它們將與相關的場景對像一起復制，它們不需要使用外部工具進行任何編譯，它們可以在線程或非線程模式下運行，它們可以通過自定義<span>Lua</span>函數或<span>Lua</span>擴展庫進行擴展。使用子腳本的另一個主要優點是：與本節中提到的後<span>3</span>種方法（即使用常規<span>API</span>）一樣，沒有通信延遲，並且子腳本是應用程序主線程的一部分（固有的同步操作）。但是，編寫腳本有幾個缺點：您無法選擇編程語言，不能擁有最快的代碼，並且除了<span>Lua</span>擴展庫之外，無法直接訪問外部函數庫。</p>
<p>可以控制機器人或模擬的另一種方法是編寫插件。插件機制允許使用回調機制，自定義<span>Lua</span>函數註冊，當然還可以訪問外部函數庫。插件通常與子腳本結合使用（例如，插件註冊自定義的<span>Lua</span>函數，當從子腳本中調用時，該<span>Lua</span>函數將回調特定的插件函數）。使用插件的主要優勢還在於，與本節中提到的後<span>3</span>種方法（即使用常規<span>API</span>）一樣，沒有通信延遲，並且插件是應用程序主線程的一部分（固有的同步操作）。插件的缺點是：它們的編程更加複雜，並且也需要使用外部編譯。另請參閱插件教程。</p>
<p>控制機器人或模擬的第三種方法是編寫依賴於遠程<span>API</span>的外部客戶端應用程序。如果您需要從外部應用程序，機器人或另一台計算機運行控制代碼，這是一種非常便捷的方法。這也使您可以使用與運行真實機器人完全相同的代碼來控制仿真或模型（例如虛擬機器人）。遠程<span>API</span>有兩個版本：基於<span>B0</span>的遠程<span>API</span>和舊版遠程<span>API</span>。</p>
<p>控制機器人或仿真的第五種方法是通過<span>ROS</span>節點。<span> ROS</span>與遠程<span>API</span>相似，是使多個分佈式進程相互通信的便捷方法。儘管遠程<span>API</span>非常輕巧且快速，但它僅允許與<span>CoppeliaSim</span>通信。另一方面，<span>ROS</span>允許幾乎將任意數量的進程相互連接，並且提供了大量兼容的庫。但是，它比遠程<span>API</span>重並且更複雜。有關詳細信息，請參閱<span>ROS</span>接口。</p>
<p>控制機器人或模擬的第六種方法是通過<span>BlueZero</span>（<span>BØ</span>）節點。與<span>ROS</span>類似，<span>BlueZero</span>是使多個分佈式進程相互通信的一種便捷方法，並且是一種輕量級的跨平台解決方案。有關詳細信息，請參考<span>BlueZero</span>界面。</p>
<p>控制機器人或模擬的第七種方法是編寫一個外部應用程序，該應用程序通過各種方式（例如管道，套接字，串行端口等）與<span>CoppeliaSim</span>插件或<span>CoppeliaSim</span>腳本進行通信。選擇編程語言（可以是任何一種語言）和靈活性是兩個主要優點。同樣，控制代碼也可以在機器人或其他計算機上運行。但是，與使用遠程<span>API</span>的方法相比，這種控制仿真或模型的方法更加乏味。</p>
<p>有<span>8</span>個與本教程相關的場景文件：</p>
<p><span>scenes / controlTypeExamples /</span>受控<span>ViaScript</span>：一個機器人是通過非線程子腳本控制的，另一個是通過線程子腳本控制的。</p>
<p><span>scenes / controlTypeExamples /</span>受控<span>ViaPlugin</span>：機器人是通過插件控制的。</p>
<p><span>scenes / controlTypeExamples / controlViaB0RemoteApi</span>：通過基於<span>B0</span>的遠程<span>API</span>來控制機器人。</p>
<p><span>scenes / controlTypeExamples /</span>受控<span>ViaLegacyRemoteApi</span>：通過舊版遠程<span>API</span>控制機器人。</p>
<p><span>scenes / controlTypeExamples / controlViaB0</span>：通過<span>BlueZero</span>界面控制機器人。</p>
<p><span>scenes / controlTypeExamples /</span>受控<span>ViaRos</span>：通過<span>ROS</span>接口控制機器人。</p>
<p><span>scenes / controlTypeExamples / controlViaRos2</span>：通過<span>ROS2</span>接口控制機器人。</p>
<p><span>scenes / controlTypeExamples /</span>受控<span>ViaTcp</span>：通過<span>LuaSocket</span>和<span>TCP</span>控制機器人。</p>
<p><img alt="" height="581" src="/images/輸出.jpg" width="752"/></p>
<p>在所有<span>8</span>種情況下，都使用子腳本，主要是為了與外界建立鏈接（例如，啟動正確的客戶端應用程序，並將正確的對象句柄傳遞給它）。有兩種其他方法可以控制機器人，模擬或模擬器本身：使用自定義腳本或附加組件。但是，不建議將它們用於控制，而應使用在模擬未運行時處理功能。</p>
<p>例如，鏈接到場景控制的<span>ViaB0RemoteApi.ttt</span>中的機器人的子腳本具有以下主要任務：</p>
<p>使用某些對象句柄作為參數啟動控制器應用程序（<span>bubbleRobClient_b0RemoteApi</span>）。基於對象<span>B0</span>的遠程<span>API</span>的服務器功能由對象<span>b0RemoteApiServer</span>提供。</p>
<p>作為另一個示例，鏈接到場景控制的<span>ViaRos.ttt</span>中的機器人的子腳本具有以下主要任務：</p>
<p>檢查是否已加載<span>CoppeliaSim</span>的<span>ROS</span>接口</p>
<p>使用某些主題名稱或對象句柄作為參數啟動控制器應用程序（<span>rosBubbleRob</span>）</p>
<p>然而，作為另一個示例，鏈接到場景控制的<span>ViaTcp.ttt</span>中的機器人的子腳本具有以下主要任務：</p>
<p>搜索空閒的套接字連接端口</p>
<p>使用所選的連接端口作為參數啟動控制器應用程序（<span>bubbleRobServer</span>）</p>
<p>本地連接到控制器應用程序</p>
<p>在每次仿真過程中，將傳感器值發送到控制器，並從控制器讀取所需的電機值</p>
<p>在每次模擬過程中，將所需的電機值應用於機器人的關節</p>
<p>運行模擬，然後復制並粘貼機器人：您將看到重複的機器人將直接運行，因為附加的子腳本負責啟動各自外部應用程序的新實例，或調用適當的插件函數。</p>
<h3>心得</h3>
<p>我們透過CoppeliaSim這本電子書學習到許多東西，而且裡面有許多功能可以供我們使用，例如裡面的假人可以被用來測量與機器人的距離，可以被偵測器偵測到的，同時具有可以放在路徑上做為輔助的對象……等，在這個電子書裡讓我們訝異的是他的API 不是只有Python能用而已，可以用許多程式來寫API，讓我們覺得自己所學的還不太足夠應該多加努力。</p>
<h2>報告</h2>
<p><a href="https://s5.aconvert.com/convert/p3r68-cdx67/ren7r-cyl88.pdf">https://s5.aconvert.com/convert/p3r68-cdx67/ren7r-cyl88.pdf</a></p>
<p>影片簡單<a href="https://youtu.be/Gj974WwbWJ4"></a>說明</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Gj974WwbWJ4" width="560"></iframe></p>
<p></p>
<p></p>
<h1>Assignment 2</h1>
<h2>Top 0文章</h2>
<p><span style="color: #ff00ff;"><strong><span style="color: #000000;">主題:</span>協同設計出更好的產品</strong></span></p>
<p><strong>今天，數位產品比以往任何時候都更加複雜。創建它們需要多個團隊</strong><br/><strong>成員，每個成員都有自己的一套技能和專業知識。例如，在Savvy，我們的客戶</strong><br/><strong>與以下人員緊密合作：產品經理，UX設計人員，視覺設計師，開發人員，內容</strong><br/><strong>戰略家和成長專家。</strong><br/><strong>我們使用設計協作來處理這種複雜性。正確完成，設計協作可助力</strong><br/><strong>每個專家都有共同的心態，流程和工具，共同建立更好的</strong><br/><strong>產品更快。</strong><br/><strong>我們編寫了此資源，以幫助其他應用程序創建者採用協作文化和流程。</strong><br/><strong>繼續學習為什麼設計協同對於創造吸引人的產品很重要，以及</strong><br/><strong>經驗。我們還將深入探討設計協作心態和文化，工具的要素</strong><br/><strong>進行有效的設計協作，以及實際工作中的設計協作示例。</strong><br/><strong><span style="color: #ff0000;">什麼是“設計”協同？</span></strong><br/><strong>在進入之前，我們需要在同一頁上了解什麼是設計協同……</strong><br/><strong>簡單來說，設計協同就是在設計優先的環境中進行協同。</strong><br/><strong>由於設計的本質，特別是我們在Savvy所做的設計，設計協同趨向於超越人們通常認為的協作。</strong><br/><strong>通常將協作定義為兩個或兩個以上的人共同完成一項任務</strong><br/><strong>為了實現共同的目標，設計協作涉及更多。</strong><br/><strong>設計協同包括更多具有不同技能，艱鉅挑戰和更大規模的人員,具有深遠影響的目標。</strong><br/><strong>您可能將協同視為兩個人掛在一塊藝術品上。它只需要溝通，團隊合作和四隻手。設計協同是指一組策展人.精心設計訪問者的體驗。他們選擇藝術品，選擇在何處以及如何懸掛藝術品，</strong><br/><strong>它所居住的房間（以及房間的照明，家具），甚至前面的房間和建築物</strong><br/><strong>整個。為什麼設計協作很重要</strong><br/><strong><span style="color: #ff0000;">您可以在沒有協同的情況下設計產品，但是需要一個協同設計過程才能完成</span></strong><br/><strong><span style="color: #ff0000;">不錯的產品。這就是設計協作如此重要的原因。</span></strong><br/><strong>我們不僅為客戶構建應用程序。精巧構建複雜且多平台的體驗</strong><br/><strong>內部系統，在某些情況下還包括整個品牌和業務。為此，我們利用專業知識</strong><br/><strong>跨多個核心學科：戰略，設計，開發和增長。每個項目都涉及</strong><br/><strong><span style="color: #ff0000;">許多人都有各自的技能和專長。</span></strong><br/><strong><span style="color: #ff0000;">設計協作將這些思想融合在一起，將他們各自的專業知識結合在一起</span></strong><br/><strong><span style="color: #ff0000;">創建解決方案，以解決共同目標的所有方面。而不是一個人遇到問題</span></strong><br/><strong><span style="color: #ff0000;">角度來看，設計協作將這個問題擺在所有專家面前，迫使他們考慮新</span></strong><br/><strong><span style="color: #ff0000;">觀點和可能性。</span></strong></p>
<p><strong>例如，我們在設計過程的早期就讓我們的開發人員參與進來，以確保我們</strong><br/><strong>盡快解決技術機會和局限性。這使我們可以有好處並推動我們的技術能力，同時進一步消除了複雜的障礙處理。它還限制了一個人可以在筒倉中工作的數量，從而使工作保持公開狀態,並強調用戶需求和產品目標。</strong><br/><strong><span style="color: #ff6600;"></span></strong></p>
<p><strong><span style="color: #ff6600;">培養設計協同心態</span></strong><br/><strong>在設計過程中建立有效的協同時，正確的思維方式大有幫助。它規定了誰進行協同，如何進行以及達到何種目的的準則。</strong><br/><strong><span style="color: #ff6600;"></span></strong></p>
<p><strong><span style="color: #ff6600;">合作適合每個人</span></strong><br/><strong>設計師有時會認為不是設計師的人沒有資格提供良好的產品</strong><br/><strong>反之。但是出色的設計不只是視覺效果。它涵蓋了有關產品的所有內容，從</strong><br/><strong>它的品牌，工程技術及其成長。</strong><br/><strong>設計協同吸引了許多人，每個人都有自己的觀點和優勢。它給大家一個聲音。這些新鮮的觀點為設計師提供了更多信息。觀點</strong><br/><strong>使設計師能夠針對其他設計有持久並有影響的選擇做出正確的決定，</strong></p>
<p><strong><span style="color: #ff6600;">開發和營銷選擇</span></strong><br/><strong>與客戶的合作和其他設計師和團隊的合作一樣重要</strong><br/><strong>成員。在Savvy，我們讓客戶參與產品的整個創作過程。我們</strong><br/><strong>花些時間來解釋選項，並與客戶進行討論以確保我們了解他們的想法。</strong><br/><strong>這使我們能夠及早獲得客戶的認可，並從明確的起點和終點開始工作。</strong><br/><strong>更大的曝光量並不是什麼好事，沒有人知道他們正在與客戶第一次合作.</strong><br/><strong>客戶合作意味著無需花費高昂成本就能更快地獲得更清晰的產品</strong><br/><strong>後退和不必要的會議。</strong><br/><strong>很容易陷入當下而忽略全局。通過更早地參與更多的人</strong><br/><strong>而且，您正在與隊友建立更緊密的聯繫，並共同承擔責任，</strong><br/><strong>對產品成功的興趣。您正在創建一個更加開放和透明的流程，因為更緊密聯繫和投入的團隊。</strong><br/><strong><span style="color: #ff6600;"></span></strong></p>
<p><strong><span style="color: #ff6600;">合作是背景性的</span></strong><br/><strong>客戶向我們提出了複雜的挑戰和目標。更不用說，我們持續努力</strong><br/><strong>與我們的客戶進行長達數月甚至好幾年的交流，並積累了過去的大量知識</strong><br/><strong>決策，研究和其他有價值的地方。</strong><br/><strong>通過採用上下文優先的方法，您可以確保每個人都處於最高水平知識。這樣，他們就可以在產品上做出最明智的決定。</strong><br/><strong>為了做到這一點，我們通過引入所有團隊成員儘早，記錄和記錄會議，建立一些重疊的地方以及過程中的下一個團隊成員就像客戶一樣。</strong><br/><strong>在個案協同的基礎上，上下文也同樣重要。請遵循以下準則以保持</strong><br/><strong>協作中的上下文優先：</strong><br/><strong>在顯示您的工作之前提供上下文。如果您正在工作，則您的工作是否出現在屏幕上</strong><br/><strong>提供背景信息，您已經失去了聽眾的注意力。</strong><br/><strong>描述您要解決的問題或要達到的目標。介紹與當前問題相關的工作。解釋您的想法以及為什麼要這麼做這些決定。請具體說明您要回饋的內容。</strong></p>
<p><strong><span style="color: #ff6600;">合作是開放，誠實和無畏的</span></strong><br/><strong>將您的工作（和您自己）放在那裡並不容易。情緒會阻礙提供</strong><br/><strong>開放和誠實的反饋，尤其是當您擔心會傷害他人的感受時。</strong><br/><strong>這並不意味著在協同中沒有情感的位置。</strong></p>
<p><strong>感覺如何在設計中很重要。我們為有情感，</strong><br/><strong>在決策中使用情感的人。離開談話可能會縮短</strong><br/><strong>潛在的想法或解決方案。其實，僅圍繞事實和數據進行實際的討論是不會的。</strong><br/><strong>提供完整圖片。在最壞的情況下，它可能是不相關或提供虛假的敘述。</strong><br/><strong>在Savvy，我們使我們的團隊對收到反饋<span style="color: #ff6600;">“無所畏懼”</span>。這意味著放手</strong><br/><strong>關於我們為自己創造的東西而被批評的任何焦慮。這也意味著了解我們</strong><br/><strong>在一起變得更強大，更有機會創造偉大的事物。無所畏懼，我們</strong><br/><strong>更好地信任並相互授權，以提供誠實和周到的反饋。</strong><br/><strong>我們的團隊還相信，不要害怕提供反饋。這意味著了解</strong><br/><strong>需要解決的問題以及客戶的品牌和目標。這也意味著要問很多</strong><br/><strong>提問以發現相關思想或幫助指導決策。</strong><br/><strong>嘗試以探索性和指導性的方式提出反饋意見，以建立並改善工作而不是拆散。您的反饋意見應具有建設性。與其說你不喜歡什麼，不如說</strong><br/><strong>反饋以指出您要幫助解決的問題。在以下方面提供可行的步驟</strong><br/><strong>改善工作，或者至少改善您的思維背後的理由。而且不要忘記</strong><br/><strong>表達您喜歡什麼以及為什麼。</strong></p>
<p><br/><strong><span style="color: #ff6600;">合作不僅僅是新的想法</span></strong><br/><strong>開放並接受協作反饋是一回事，解析這些想法是另一回事</strong><br/><strong>並將它們用作激發自己的催化劑。這是一項發展起來的高級技能</strong><br/><strong>時間。一種實踐方法是成為更好的聽眾。</strong><br/><strong>通常，在與他人交談時，我們會更多地考慮接下來要說的內容</strong><br/><strong>比別人說什麼這會影響反饋過程，尤其是在設計中，<span style="color: #ff6600;">因為我們</span></strong><br/><strong><span style="color: #ff6600;">在聽到其他意見或解決方案之前，通常都知道我們要說什麼。</span></strong><br/><strong><span style="color: #ff6600;">當您選擇先聆聽然後再做出反應時，它可以讓您完全理解反饋</span></strong><br/><strong>有人在介紹您，並讓您更深入-他們使用的觀點是什麼</strong><br/><strong>他們來自哪裡？很有可能這是您在</strong><br/><strong>創建過程。通過聽取並理解反饋的上下文和推理</strong><br/><strong>您正在接受，正在向更多的視角，思維方式和體驗方式開放您的設計。然後，您可以針對挑戰，目標和舉例子測試這些新觀點。</strong><br/><strong>您正在設計用於查看是否更適合用戶。</strong><br/><strong><span style="color: #ff6600;">當所有協作者都在積極聆聽時，更容易接受反饋。</span></strong><br/><strong><span style="color: #ff6600;">最終，提供良好反饋的技能來自學習如何獲得反饋。當我們做一個</span></strong><br/><strong><span style="color: #ff6600;">努力成為更好的聽眾，我們也發現自己變得更加謙虛<span style="color: #000000;">，我們認為，更好的設計師。<br/>尋找和使用正確的設計協作工具<br/>正確的工具在增強團隊的設計協作思維方面大有幫助。 在這<br/>部分，您將了解在協作工具中尋找什麼。 我們還建議我們的工具及</span></span><span style="color: #ff6600;"><span style="color: #000000;">自己的經驗。</span></span></strong></p>
<p><strong><span style="color: #ff6600;">選擇合適的工具</span></strong></p>
<p><strong><span style="color: #000000;">有效的協作工具為協作者消除了所有障礙，使他們能夠快速輕鬆地訪問和<br/>與工作互動。 這將重點放在提供反饋上。 他們還允許其他人<br/>在不破壞原始設計的情況下進行協作。<br/>過去，我們使用依賴於提供基本版本控制的工具，而不是真正的<br/>協作功能。 例如，設計人員將保存一個Sketch文件並將其上傳到Dropbox。<br/>然後，另一個團隊成員將下載它，進行處理，然後重新上傳。 沒有簡單的方法<br/>在文件移交給他人的情況下進行更改。 我們嘗試了與Github類似的方法，<br/>實踐證明，該工具非常適合管理代碼庫，但在迭代設計工作中卻不那麼重要。<br/>不用說，這些版本控制流程使我們的協作更加耗時，<br/>令人困惑，而且非常不合作。<br/>現在，我們根據協作類型從多種更高級的工具中進行選擇,並且想要實現。</span></strong></p>
<p><strong><span style="color: #ff6600;">FIGMA</span></strong></p>
<p><strong><span style="color: #000000;">這是一個協作優先的共享工作區工具。 Figma非常適合在其中有多個人<br/>設計文件的相同區域。 您可以觀看隊友設計或在同一個設計上一起即時工作<br/>。</span></strong></p>
<p><strong><span style="color: #000000;">好處:</span></strong></p>
<p><strong><span style="background-color: #ffffff; color: #000000;">Figma降低了某人在筒倉中工作的能力。<br/>無需添加不必要的修飾或創建靜態可交付結果即可實現協作。 所以<br/>您無需更改工作流程即可展示設計。<br/>可以輕鬆地在其本機環境中查看並與之交互，並隨意進行調整。<br/>何時使用：流量文檔，高保真線框，即時協作和行走<br/>客戶通過一系列屏幕來解釋並獲得有關設計方向的反饋。</span></strong></p>
<p><strong><span style="background-color: #ffffff; color: #ff6600;">Marvel</span></strong></p>
<p><strong><span style="background-color: #ffffff; color: #000000;">雖然Figma傾向於感覺更自由和靈活，但Marvel允許更標準化的形式<br/>合作。 這也使我們的客戶可以輕鬆地與我們合作。</span></strong></p>
<p><strong><span style="background-color: #ffffff; color: #000000;">好處：<br/>Marvel是一個更簡潔，更規範和集中的空間，非常適合與非設計團隊成員合作<br/>。</span></strong></p>
<p><strong><span style="background-color: #ffffff; color: #000000;">它消除了客戶支付帳戶或深入了解工具的所有需求<br/>去看工作。<br/>客戶可以下載屏幕並通過Marvel在設備環境中查看它們的運行情況<br/>應用程式。<br/>使用時間：與客戶和開發人員一起呈現更多最終設計工作。 （學習關於<br/>Marvel與其他原型工具的比較。）</span></strong></p>
<p><strong><span style="color: #ff6600;"><span style="background-color: #ffffff;">其他合作工具</span></span></strong></p>
<p><strong><span style="color: #000000;"><span style="background-color: #ffffff;">Zeplin是一個有用的傳遞工具，可讓開發人員深入了解設計的細節。<br/>工作。 （我們在這裡更深入地討論Zeplin。）<br/>Quip是集思廣益和產品/過程文檔的絕佳平台。 我們用它來記錄<br/>並組織團隊成員在工作時需要了解的所有背景和知識<br/>一個專案。 對於集思廣益而不是視覺關注的新想法也很有用。<br/>請注意，還有許多其他工具可以為協作增加類似的好處，<br/>上面列出的。 該列表代表了在我們日常工作中對我們有效的工具<br/>協作，並不表示所有選項都可能對您的團隊有效.</span></span></strong></p>
<p><strong><span style="color: #ff6600;"><span style="background-color: #ffffff;">精明的設計合作過程在實踐中</span></span></strong></p>
<p><strong><span style="color: #000000;"><span style="background-color: #ffffff;">現在，讓我們採用上面概述的最佳實踐和工具，並展示它們如何組合在一起。<br/>現實生活中的情況。 我們將使用Press Play應用程序中的實時繪圖體驗來演示<br/>設計協作的重要性。 這項經驗涉及到跨學科的團隊成員數量，包括視覺設計師，UX設計人員，開發人員，產品經理，當然還有客戶。</span></span></strong></p>
<p><strong><span style="color: #000000;"><span style="background-color: #ffffff;"> 處境與挑戰</span></span></strong></p>
<p><strong><span style="color: #000000;"><span style="background-color: #ffffff;">Press Play是一個抽獎活動應用程序，可保存每日，每周和每月的圖紙。 用戶獲得門票<br/>觀看廣告，然後選擇五個表情符號輸入繪圖。 然後根據<br/>他們的選擇如何與圖形的隨機選擇表情符號匹配。 這個特殊的任務有<br/>我們為正在等待現場繪畫結果的用戶創造了一個有趣而激動人心的現場體驗。<br/>對於我們來說，為這種體驗創建類似遊戲的動畫非常重要。 我們特別想要<br/>在用戶去看他們的屏幕時在屏幕上喚起一種嬉戲和期待感<br/>所選表情符號與抽獎活動附圖中的表情符號匹配。<br/>就是說，我們需要注意動畫所需的複雜程度及其影響<br/>在整個產品的時間表和成本上。 我們的目標是將保真度提高到<br/>合理的時間，而不會顯著影響項目的預算。</span></span></strong></p>
<p><strong><span style="color: #000000;"><span style="background-color: #ffffff;"><span style="color: #ff6600;">合作過程</span></span></span><span style="color: #000000;"><span style="background-color: #ffffff;"><br/></span></span></strong></p>
<p><strong><span style="color: #000000;"><span style="background-color: #ffffff;"><span style="color: #ff6600;">第一階段：線框和集思廣益</span><br/>首先，精明的用戶體驗設計師創建了Press Play的整體用戶體驗和線框，確定了<br/>需要屏幕和每個屏幕的時間安排。 她還提出了一個粗略的概念（如圖<br/>右圖）用於實時繪圖動畫，根據客戶的需求和項目的已建立UX。<br/>她向產品經理和視覺設計師展示了線框和粗糙的動畫設計師。 然後，這三個人都與客戶會面，因此每個人都可以直接聽到反饋。<br/></span></span></strong></p>
<p><strong><span style="color: #000000;"><span style="background-color: #ffffff;">第二階段：研究與背景</span></span></strong></p>
<p><strong><span style="color: #000000;"><span style="background-color: #ffffff;">精明的視覺設計師負責創建實際的實時繪圖動畫<br/>新鮮的眼睛，並且對Press Play產品沒有太多的先驗知識。為了起床，他<br/>與UX設計人員和產品經理進行了深入的交談。他還致力於其他研究<br/>有時間了解整體產品目標，挑戰並熟悉工作<br/>至今。如前所述，他是線框演示的一部分，並為客戶反饋。<br/>在這種情況下，他進行了一些與手頭任務直接相關的其他研究。<br/>通過這樣做，他確保自己了解現場繪畫體驗的要求，目標和挑戰。他查看了具有類似經驗和保真度的其他應用，並參考了動畫，以了解最終動畫到底需要顯示什麼（在這種情況下，表情符號和用戶的表情符號選擇）。</span></span></strong></p>
<p><strong><span style="color: #000000;"><span style="background-color: #ffffff;">在過於束縛解決方案之前，他遇到了一個精明的人<br/>iOS開發人員了解技術限制和注意事項。<br/>然後，我們的視覺設計師和UX設計師集思廣益，對視覺效果至關重要。他們<br/>同意需要為用戶建立緩慢的提示以建立懸念/期望<br/></span></span></strong></p>
<p><strong><span style="color: #000000;"><span style="background-color: #ffffff;"><span style="color: #ff6600;">階段3：循環和反饋</span><br/>當我們的視覺設計師沿多個不同方向工作時，他選擇了UX設計師<br/>聊聊他在Figma中的進度和設計。通過討論工作，他們激發了更多<br/>想法和迭代，同時確保它們符合客戶期望。還有更多<br/>他手下有很多可靠的選擇，他再次與iOS開發人員會面，以確保一切都在<br/>從技術角度出發。<br/></span></span></strong></p>
<p><strong><span style="color: #000000;"><span style="background-color: #ffffff;"><span style="color: #ff6600;">階段4：客戶的反饋和發展</span><br/>當我們找到更多，更最終的體驗版本時，視覺設計師走了<br/>通過他們與客戶一起使用Figma。 Press Play產品經理和UX設計師<br/>還提供了反饋和指導。<br/>一旦他們都了解了引起顧客興趣的東西，視覺設計師便開始最大限度地發揮作用。<br/>視覺效果並使它們為開發做好準備。他繼續與iOS開發人員合作，<br/>在技術層面上充分利用該概念。<br/>最終結果<br/>Press Play的實時繪圖動畫是工作中設計協作的一個範例。<br/>一些跨學科專家一起解決更大的設計和開發挑戰<br/><span style="color: #ff6600;">意思是。沒有設計協作，我們將找不到理想的交集</span><br/>用戶體驗，視覺和技術。<br/>當客戶在他的應用程序中看到動畫生動時，他稱其為“開創性的”。<br/>而且，這種Press Play體驗的研究，合作和創造對我們有幫助<br/>發現產品用戶旅程中的空白。最初，現場繪畫的目的是為了娛樂<br/>向用戶顯示結果的方式。在設計過程中，我們意識到，如果用戶不觀看實時繪圖，他們就會迷失方向，無法體驗終結該圖紙的用戶旅程。<br/>基於這一發現，我們決定在其他兩個地方也改進該應用程序。我們添加了一個<br/>獲勝者範圍的結果/實時繪圖元素，以及用戶的輸贏歷史記錄部分<br/>應用程序的細節部分。最後，需要用戶體驗,來設計協同使我們得以實現這一些未實現的目標。</span></span></strong></p>
<p><strong><span style="color: #ff6600;"><span style="background-color: #ffffff;">結論說明</span></span></strong></p>
<p><strong><span style="color: #993300;"><span style="background-color: #ffffff;">設計協作需要解決建造中伴隨的複雜，關鍵問題<br/>很棒的產品和經驗。 通過利用多個團隊成員的專業知識<br/>跨學科的設計協作可確保團隊從各個角度應對挑戰<br/>並尋求更好的解決方案。 借助正確的思維方式，工具和流程，進行設計協作<br/>使團隊能夠通過創造性思維和迭代來更深入。<br/>我們希望本指南為您提供良好的基礎，以便您可以構建自己的有效設計<br/>協作過程。 您可以在Savvy博客上了解有關設計和產品策略的更多信息，<br/>並隨時在Savvy Apps網站上與我們聯繫以尋求幫助。</span></span></strong></p>
<h3>感想</h3>
<p><strong><span style="color: #ff6600;">40723114:</span></strong></p>
<p><span style="color: #000000;"><strong>在看完Top 0 的文章後,很喜歡文章裡的一句話,就是協同設計是每個人都能做的,並不是那些有專業背景的人才能做設計,還有努力成為更好的聽眾,聆聽每個人的想法,並且學習謙虛,的確,在協同設計過程中,會遇到各式各樣的人,但能夠真的靜下心來,去聆聽每個人想法的人,真的很少,有些人雖然專業背景很夠,並且很強,但是卻自我意識太強,很難接受別人的想法,在這篇文章裡,有反思自己有許多的不足,例如:太急性子,專業背景以及英文有待加強等等...,希望能夠補足,成為一名傑出並且懂得傾聽別人想法的設計者.</strong></span></p>
<p><span style="color: #000000;"><strong><span style="color: #ff6600;">40723123:</span></strong></span></p>
<p><strong><span style="color: #000000;">看完Topic 0之後我終於知道協同設計不只是自己的專業知識，更是各方面專業人士間的意見溝通與達成平衡的一個重要課題，如果你的專業背景很厲害但是卻無法接受別人非專業人士的看法，或是與他們協調溝通那你會是一個非常不好的協同者。</span></strong></p>
<p><span style="color: #000000;"><strong><span style="background-color: #ffffff;"></span></strong></span></p>
<p><span style="color: #ff6600;"><strong><span style="background-color: #ffffff;"></span></strong></span></p>
<p><span style="background-color: #ffffff; color: #000000;"><strong></strong></span></p>
<h2>webots tutorial</h2>
<h3>編成基礎(使用數值優化方法,控制器插件)</h3>
<p>使用數值優化方法</p>
<p>指數</p>
<ul>
<li><a href="https://cyberbotics.com/doc/guide/using-numerical-optimization-methods#choosing-the-correct-supervisor-approach"><span>選擇正確的主管方法</span></a>
<ul>
<li><a href="https://cyberbotics.com/doc/guide/using-numerical-optimization-methods#using-a-single-controller"><span>使用單個控制器</span></a></li>
<li><a href="https://cyberbotics.com/doc/guide/using-numerical-optimization-methods#using-two-distinct-types-of-controllers"><span>使用兩種不同類型的控制器</span></a></li>
</ul>
</li>
<li><a href="https://cyberbotics.com/doc/guide/using-numerical-optimization-methods#resetting-the-robot"><span>重置機器人</span></a>
<ul>
<li><a href="https://cyberbotics.com/doc/guide/using-numerical-optimization-methods#using-the-wb_supervisor_field_set_-and-wb_supervisor_simulation_reset_physics-functions"><span>使用wb_supervisor_field_set_ *</span><span>和wb_supervisor_simulation_reset_physics</span><span>函數</span></a></li>
<li><a href="https://cyberbotics.com/doc/guide/using-numerical-optimization-methods#using-the-wb_supervisor_world_reload-function"><span>使用wb_supervisor_world_reload</span><span>函數</span></a></li>
<li><a href="https://cyberbotics.com/doc/guide/using-numerical-optimization-methods#using-the-wb_supervisor_world_reset-function"><span>使用wb_supervisor_world_reset</span><span>函數</span></a></li>
<li><a href="https://cyberbotics.com/doc/guide/using-numerical-optimization-methods#by-starting-and-quitting-webots"><span>通過啟動和退出Webots</span></a></li>
</ul>
</li>
</ul>
<p> </p>
<p>選擇正確的主管方法</p>
<p>在<span>Webot</span>中有幾種使用優化算法的方法。大多數方法都依賴於<span><a href="https://cyberbotics.com/doc/reference/supervisor">Supervisor</a></span>控制器。</p>
<p>數值優化通常可以分解為兩個單獨的任務：</p>
<ol>
<li>運行優化算法：系統搜索，隨機搜索，遺傳算法（<span>GA</span>），粒子群優化（<span>PSO</span>），模擬退火等。</li>
<li>使用優化算法指定的一組參數運行機器人行為。</li>
</ol>
<p>需要決定的重要事情之一是，這兩個不同任務的實現應該進入同一個控制器還是在兩個單獨的控制器中。讓我們討論兩種方法：</p>
<p></p>
<p>使用單個控制器</p>
<p>如果您的仿真一次只需要評估一個機器人，例如，您正在優化人形機器人的運動步態或單個機器人的行為，則可以在同一控制器中實現這兩個任務；這樣會導致代碼更簡單。這是僅使用一個控制器對兩個參數<em><span>a</span></em>和<em><span>b</span></em>進行系統優化的偽代碼示例：</p>
<p><img alt="" height="773" src="/images/翻譯.jpg" width="951"/></p>
<p>在此示例中，機器人運行了<span>30</span>個模擬秒，然後評估了適應度，然後將機器人移回到其初始位置。請注意，此控制器需要在其字段設置為的<a href="https://cyberbotics.com/doc/reference/robot"><span>機器人</span></a>節點中執行，以訪問讀取和重置機器人位置所需的功能。supervisorTRUEwb_supervisor_field_*</p>
<h4>使用兩種不同類型的控制器</h4>
<p>相反，如果您的仿真需要同時執行多個機器人，例如群體機器人，則建議使用兩種不同類型的控制器：一種用於優化算法，另一種用於機器人的行為。優化算法應該放在<a href="https://cyberbotics.com/doc/reference/supervisor">Supervisor</a>控制器中，而機器人的行為可以放在常規（非<span>Supervisor</span>）控制器中。</p>
<p>由於這些控制器將在單獨的系統進程中運行，因此它們將無法訪問彼此的變量。但是，為了指定需要評估的參數集，他們將不得不通過其他某種方式進行通信。可能並且建議使用<span>Webots </span><a href="https://cyberbotics.com/doc/reference/emitter"><span>發射器</span></a>和<a href="https://cyberbotics.com/doc/reference/receiver"><span>接收器</span></a>在<a href="https://cyberbotics.com/doc/reference/supervisor">Supervisor</a>控制器和其他控制器之間交換信息。例如，在典型情況下，<a href="https://cyberbotics.com/doc/reference/supervisor">Supervisor</a>控制器會將評估參數（例如，基因型）發送給機器人控制器。機器人控制器聆聽其<a href="https://cyberbotics.com/doc/reference/receiver"><span>接收器</span></a>，等待一組新參數。收到後，機器人控制器開始執行由參數集指定的行為。在這種情況下，<a href="https://cyberbotics.com/doc/reference/supervisor">Supervisor</a>控制器需要一個<a href="https://cyberbotics.com/doc/reference/emitter">Emitter<span>，</span></a>而每個機器人都需要一個<a href="https://cyberbotics.com/doc/reference/receiver">Receiver</a>。</p>
<p>根據算法需求，可以在<a href="https://cyberbotics.com/doc/reference/supervisor">Supervisor</a>控制器或單個機器人控制器中評估適應性。如果在機器人控制器中進行評估，則需要將適應性結果發送回<a href="https://cyberbotics.com/doc/reference/supervisor">Supervisor</a>控制器。這種雙向通信類型需要使用其他<a href="https://cyberbotics.com/doc/reference/emitter"><span>發射器</span></a>和<a href="https://cyberbotics.com/doc/reference/receiver"><span>接收器</span></a>。</p>
<p>重置機器人</p>
<p>使用優化算法時，您可能需要在每次適應性評估之後或之前重置機器人。有幾種重置機器人的方法：</p>
<h4>使用<span>wb_supervisor_field_set_ *</span>和<span>wb_supervisor_simulation_reset_physics</span>函數</h4>
<p>您可以使用wb_supervisor_field_set...和wb_supervisor_simulation_reset_physics功能輕鬆重置機器人的位置，方向和物理狀態，下面是一個示例：</p>
<p><img alt="" height="319" src="/images/翻譯2.jpg" width="948"/></p>
<p>上述方法的缺點在於，它僅會重置機器人的主要位置和方向。這對於某些類型的優化可能很好，但對於其他類型則不夠。儘管可以向要重置的數據集添加更多參數，但是有時很難重置所有內容。這樣既不會重置電動機位置，也不會重置機器人控制器。應當使用該wb_motor_set_position功能重置電動機位置，並且應該通過從主管進程向機器人控制器進程發送消息（使用<span>Webots </span><a href="https://cyberbotics.com/doc/reference/emitter"><span>發射</span></a><a href="https://cyberbotics.com/doc/reference/receiver"><span>器</span></a> / <a href="https://cyberbotics.com/doc/reference/receiver"><span>接收器</span></a>通信系統）來重置機器人控制器。機械手控制器程序應該能夠處理此類消息並相應地重置其狀態。</p>
<h4>使用<span>wb_supervisor_world_reload</span>函數</h4>
<p>此功能從一開始就重新啟動物理模擬和所有控制器。使用此方法，所有設置都將重置，包括物理特性，電機位置和控制器。但是此功能還會重新啟動稱為該wb_supervisor_world_reload功能的控制器，這通常是運行優化算法的控制器，結果是失去了優化狀態。因此，對於使用這種技術，有必要開發可以保存和恢復優化算法完整狀態的功能。優化狀態應在調用wb_supervisor_world_reload函數之前保存，並在<a href="https://cyberbotics.com/doc/reference/supervisor">Supervisor</a>控制器重新啟動時重新加載。這是一個偽代碼示例：</p>
<p><img alt="" height="800" src="/images/翻譯3.jpg" width="950"/></p>
<p><img alt="" height="379" src="/images/翻譯4.jpg" width="948"/></p>
<p>例如，如果將此技術與遺傳算法一起使用，則該optimizer_save_state功能應至少保存當前<span>GA</span>群體的所有基因型和適應性結果。如果將此技術與<span>“</span>粒子群優化<span>”</span>一起使用，則該optimizer_save_state功能至少應保存當前群中所有粒子的位置，速度和適應性。</p>
<h4>使用<span>wb_supervisor_world_reset</span>函數</h4>
<p>與該<a href="https://cyberbotics.com/doc/reference/supervisor#wb_supervisor_world_reload">wb_supervisor_world_reload</a>功能類似，此功能可重置物理模擬。但是，它不會重新啟動控制器。該功能的優點是可以使用該<a href="https://cyberbotics.com/doc/reference/supervisor#wb_supervisor_node_restart_controller">wb_supervisor_node_restart_controller</a>功能僅重新啟動所需的控制器。通常情況下，你將重新啟動<a href="https://cyberbotics.com/doc/reference/robot"><span>機器人</span></a>控制器，而不是<a href="https://cyberbotics.com/doc/reference/supervisor"><span>主管</span></a>之一。因此，<a href="https://cyberbotics.com/doc/reference/supervisor">Supervisor</a>控制器無需保存和恢復優化算法的完整狀態。</p>
<h4>通過啟動和退出<span>Webots</span></h4>
<p>最後，最後一種方法是啟動和退出<span>Webots</span>程序以進行每個參數評估。這聽起來似乎有些開銷，但實際上，與評估控制器所需的時間相比，<span>Webots</span>的啟動時間通常很短，因此這種方法非常合理。</p>
<p>例如，可以從<span>Shell</span>腳本或適合於運行優化算法的任何類型的程序中調用<span>Webot</span>。每次啟動<span>Webot</span>顯然都會完全重載世界，因此每個機器人都將從相同的初始狀態啟動。這種方法的缺點是優化算法必須在<span>Webots</span>之外進行編程。可以使用任何編程語言（例如<span>Shell</span>腳本，<span>C</span>，<span>PHP</span>，<span>perl</span>等）編寫此外部程序，前提是可以像<span>C</span>標準system函數那樣調用<span>Webots</span>並等待其終止。相反，必須在<span>Webots</span>控制器中實現參數評估。</p>
<p>通過這種方法，優化算法和機器人控制器在單獨的系統過程中運行，但是它們必須相互通信才能交換參數集和適用性結果。一種簡單的方法是使它們通過使用文本文件進行通信。例如，優化算法可以將基因型值寫入文本文件，然後調用<span>Webots</span>。當<span>Webots</span>啟動時，機器人控制器讀取基因型文件並執行參數評估。機械手控制器完成評估後，會將適應性結果寫入另一個文本文件，然後調用該wb_supervisor_simulation_quit函數終止<span>Webot</span>。然後，控制流程返回到優化程序，該程序可以讀取結果適應度，將適應度與當前基因型相關聯並繼續進行下一個基因型。</p>
<p>這是機器人評估控制器可能的（偽代碼）實現：</p>
<p><img alt="" height="719" src="/images/翻譯5.jpg" width="949"/></p>
<p>您將在<span>Webots</span>發行中找到使用優化技術進行模擬的完整示例：在<span>“ </span><span><a href="https://github.com/cyberbotics/webots/tree/master/projects/samples/curriculum/worlds">WEBOTS_HOME / projects / samples / curriculum / worlds</a></span> ”目錄中查找名為<span>“ advanced_pa</span>rticle_swarm_optimization.wbt”和<span>“ advanced_genetic_algorithm.wbt”</span>的<span><a href="https://github.com/cyberbotics/webots/tree/master/projects/samples/curriculum/worlds"><span>世界</span></a></span>。這些例子在<span><a href="http://en.wikibooks.org/wiki/Cyberbotics'_Robot_Curriculum">Cyber<span></span>botics<span>機器人課程</span></a></span>的<em>高級編程練習</em>中進行了描述。</p>
<p></p>
<p> </p>
<p>控制器插件</p>
<p>控制器功能可以通過用戶實現的插件進行擴展。控制器插件的目的是簡化機器人特定的機器人窗口和遠程控制包裝程序的編程。</p>
<p>對控制器插件進行編程而不是直接在控制器中進行編程更加方便，因為它大大提高了代碼的模塊化和可伸縮性。例如，一個機器人窗口可以用於多個機器人。</p>
<p>指數</p>
<ul>
<li><a href="https://cyberbotics.com/doc/guide/controller-plugin#fundamentals"><span>基本原理</span></a></li>
<li><a href="https://cyberbotics.com/doc/guide/controller-plugin#robot-window"><span>機器人窗口</span></a></li>
<li><a href="https://cyberbotics.com/doc/guide/controller-plugin#remote-control-plugin"><span>遠程控制插件</span></a></li>
</ul>
<p>基本原理</p>
<p>無論使用哪種語言，控制器可執行文件在啟動時都與<span>Webots</span>控制器庫（<span>libController</span>）鏈接。控制器插件是一個共享庫，由<span>libController</span>在特定事件後根據其類型動態加載（在運行時）。</p>
<p>下<a href="https://cyberbotics.com/doc/guide/controller-plugin#controller-plugin-overview"><span>圖</span></a>顯示了控制器插件系統的概述。在此圖中，虛線箭頭顯示瞭如何加載共享庫，大虛線表示進程間通信（<span>IPC</span>）。<span>libController</span>和<span>Webots</span>之間的<span>IPC</span>是一個管道（在<span>Windows</span>中，這是一個命名管道，否則是一個本地域套接字）。<span>libRemoteControl</span>和真實機械手之間的<span>IPC</span>由用戶定義（<span>TCP / IP</span>，串行等）。</p>
<p>該系統的設計如下。所有實體（控制器，遠程控制庫和機械手窗口庫）應僅調用<span>libController</span>接口（<span>Webots API</span>）功能。出於模塊化原因，控制器不應知道其機器人窗口和實際機器人。唯一的例外是有關機械手窗口庫的信息，該窗口庫可以知道遠程控制庫以進行初始化和監視。這可以通過通過了<span>libController API</span>來完成wb_robot_get_mode，wb_robot_set_mode和wb_remote_control_custom_function功能。當然，這些規則很容易被打破，因為每個實體都運行在同一個流程中。但是，我們建議您尊重他們以獲得良好的設計。</p>
<p>控制器插件被設計為用<span>C / C ++</span>編寫，因為結果應該是一個動態庫。但是，當然可以使用它們之間的<span>C / C ++</span>包裝器以其他語言編寫它們。</p>
<p>加載後，<span>libController</span>會調用一些控制器插件功能（入口點）。必須定義一組入口點，以使控制器插件順利運行。這些入口點中的一些是必需的，而某些是可選的。</p>
<p>所述<a href="https://cyberbotics.com/doc/reference/robot"><span>機器人</span></a>節點通過其定義了控制器的插件的位置<em>窗口</em>及其<em>REMOTECONTROL</em>字段。</p>
<p>控制器插件在進程的主線程（也稱為<span>GUI</span>線程）中運行：與控制器可執行文件相同。這意味著，如果插件的入口點被阻止，則控制器也將被阻止。並且如果插件崩潰，則控制器也崩潰。</p>
<p>《<span><a href="https://cyberbotics.com/doc/reference/robot"><span>參考手冊》中</span></a></span>介紹了將<em>窗口</em>和<em>遙控器</em>轉換為現有路徑的搜索算法。</p>
<p>借助主<span>Makefile</span>（與用於構建控制器的文件相同）來構建每個分佈式共享庫：</p>
<p>WEBOTS_HOME/resources/Makefile.include</p>
<p><img alt="" height="439" src="/images/翻譯6.jpg" width="848"/></p>
<p>機器人窗口</p>
<p>機器人窗口使程序員可以有效地為其機器人創建自定義用戶界面。可以通過雙擊虛擬機器人或使用<a href="https://cyberbotics.com/doc/guide/the-3d-window#context-menu"><span>上下文菜單</span></a>來打開機器人窗口。<a href="https://cyberbotics.com/doc/reference/robot"><span>機械手</span></a>節點的<em>窗口</em>字段指定機械手窗口。</p>
<p>機器人窗口以<span>HTML</span>格式實現，並提供以下功能：</p>
<ol>
<li>他們依靠<span>HTML</span>佈局和<span>JavaScript</span>編程。</li>
<li>它們使用兩個<span>JavaScript</span>函數直接與機器人控制器通信：window("&lt;robot window name&gt;").receive和webots.window("&lt;robot window name&gt;").send。等效的控制器功能是wb_robot_wwi_receive_text和wb_robot_wwi_send_text。</li>
<li>它們已經可以在網絡上使用，可以用來在網頁上顯示機器人窗口。</li>
</ol>
<p>robots/thymio/thymio2.wbt示例仿真中提供了一個<span>HTML</span>機械手窗口的簡單示例，並演示了：</p>
<ul>
<li>如何在機器人窗口中顯示傳感器信息。</li>
<li>如何從機器人窗口向控制器程序發送用戶界面事件（例如鼠標單擊）。</li>
<li>如何從控制器程序更改機器人窗口的標題。</li>
</ul>
<p>HTML機械手窗口可以與使用任何受支持的編程語言（即<span>C</span>，<span>C ++</span>，<span>Python</span>，<span>Java</span>，<span>MATLAB</span>和<span>ROS</span>）編寫的控制器程序進行通信。如果在模擬運行過程中更改或重新啟動了<a href="https://cyberbotics.com/doc/reference/robot"><span>機器人</span></a>的控制器，則與同一<a href="https://cyberbotics.com/doc/reference/robot"><span>機器人</span></a>節點關聯的機器人窗口也將重新啟動。</p>
<p>遠程控制插件</p>
<p>遠程控制插件允許使用<span>Webots API</span>輕鬆有效地創建接口，以與真實的機器人進行通信。遠程控制庫的主要目的是使用與真實機器人通信的協議來包裝機器人使用的所有<span>Webots API</span>函數。通常，程序（客戶端）在真實機器人上運行，並對通信協議進行解碼以與真實機器人設備進行對話。</p>
<p>當實體調用wb_robot_set_modelibController函數時，將初始化遠程控制庫。該實體通常是<span>libRobotWindow</span>，因為使用<span>GUI</span>初始化通信（即輸入機器人的<span>IP</span>地址等）非常方便。</p>
<p>遠程控制庫有兩個入口點：</p>
<ul>
<li>bool wbr_init(WbrInterface *ri)</li>
</ul>
<p>libController調用此函數以初始化遠程控制庫。在第一個wb_robot_set_mode函數調用之後調用它。該功能的目標是將給定的WbrInterface功能與遠程控制庫中的功能映射到結構中。</p>
<ul>
<li>void wbr_cleanup()</li>
</ul>
<p>libController調用此函數以清理庫。</p>
<p>該WbrInterface結構具有多個功能（強制性），必須對其進行映射才能使遠程控制庫平穩運行。他們來了：</p>
<ul>
<li>bool wbr_start(const char *args)</li>
</ul>
<p>當應該開始與真實機器人的連接時（即<a href="https://cyberbotics.com/doc/reference/robot#wb_robot_set_mode">wb_robot_set_mode(WB_MODE_REMOTE_CONTROL, ...)</a>從控制器調用時），將調用此函數。該函數的返回值應告知連接是否成功。該參數與wb_robot_set_mode初始化遙控器時給該功能的參數匹配。由於機器人窗口庫通常負責調用該wb_robot_set_mode函數，因此它們之間傳遞的結構應該匹配。</p>
<ul>
<li>void wbr_stop()</li>
</ul>
<p>當與真實機器人的連接應停止時，將調用此函數。通常，應該在停止連接之前發送停止實際機器人執行器的命令。</p>
<ul>
<li>bool wbr_has_failed()</li>
</ul>
<p>libController經常調用此函數以檢查連接的有效性。此函數返回的值應始終與連接有效性匹配。</p>
<ul>
<li>void wbr_stop_actuators()</li>
</ul>
<p>調用此功能可停止實際機器人的執行器。當用戶按下模擬器的暫停按鈕時，將調用此方法。</p>
<ul>
<li>int wbr_robot_step(int period)</li>
</ul>
<p>當控制器進入步進循環時，將調用此功能。此功能的目的是發送執行器命令，然後讀取啟用的傳感器的值。定時問題應該在那裡解決。機械手應至少等待<em>一段時間（</em>毫秒），如果<span> </span>超過該<em>時間段，</em>則返回增量時間。</p>
<p>如上所述，必須與真實機器人一起使用的所有<span>Webots API</span>功能都必須包裝在遠程控制庫中。為達到這個：</p>
<ul>
<li>必須將<span>libController</span>的內部狀態設置為與機械手的當前狀態匹配。</li>
</ul>
<p>通常，當已知傳感器的值時wbr_sensor_set_value，必須調用相應的<span> </span>功能。</p>
<ul>
<li>發送給<span>libController</span>的命令必須包裝。</li>
</ul>
<p>通常，在設置執行器的命令時，將wbr_actuator_set_value)調用相應的<span> </span>功能，並且必須將其發送給實際的機器人。</p>
<p>遠程控制<span>API</span>和WbrInterface結構的完整定義包含在以下文件中：</p>
<p>WEBOTS_HOME/include/controller/c/webots/remote_control.h</p>
<p>例如，如果您希望能夠使用真實機器人的距離傳感器，則必須包裝該wbr_set_sampling_period函數（設置遠程控制庫的內部狀態以僅在需要時讀取此距離傳感器），然後調用wbr_distance_sensor_set_value刷新距離傳感器後（通常到wbr_robot_step函數中）將函數存儲到遠程控制庫中。</p>
<p>可以在以下目錄中找到完整的示例（使用藍牙與<span>e-puck</span>機器人通信）：</p>
<p>WEBOTS_HOME/projects/robots/e-puck/plugins/remote_controls/e-puck_bluetooth</p>
<h3>webots 入門</h3>
<h4>用戶介面</h4>
<p></p>
<p><strong></strong></p>
<p><span>Webots GUI由四個主要窗口組成：顯示並允許您與3D模擬進行交互的</span><em><span><span>3D窗口</span></span></em><span><span>，</span><span>表示當前世界的層次結構</span><span>的“<span> </span></span></span><em><span><span>場景樹”</span></span></em><span><span>，允許您編輯源代碼</span><span>的“<span> </span></span></span><em><span><span>文本”編輯器</span></span></em><span><span>，以及最後，</span><span>同時顯示編譯和控制器輸出</span><span>的</span></span><em><span><span>控制台</span></span></em><span><span>。</span></span></p>
<p><span><span><img alt="" height="268" src="/images/main_window.thumbnail.jpg" width="481"/></span></span></p>
<p><span><span><span>GUI有九個菜單</span></span></span></p>
<p><span style="background-color: #ff9900;"><code>File, Edit, View, Simulation, Build, Overlays, Tools, Wizards</code>和<code>Help</code>。</span></p>
<h6><strong><span style="background-color: #ffffff;">文件菜單</span></strong></h6>
<p><strong><span>文件</span></strong><span>菜單允許您執行常規的文件操作：加載，保存等。</span></p>
<ul>
<li>
<p><span><span>所述</span></span><strong><span><span>新世界</span></span></strong><span><span>菜單項目（和按鈕）中只含有模擬窗打開一個新的世界</span></span><a href="https://cyberbotics.com/doc/reference/elevationgrid"><span><span>ElevationGrid</span></span></a><span><span>，顯示為10×10平方1米×1米的表面上的棋盤。</span></span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/open-button.png" width="26"/><span><span>“<span> </span></span></span><strong><span><span>打開世界...”</span></span></strong><span><span>菜單項（和按鈕）打開一個文件選擇對話框，該對話框允許您選擇要加載的“ .wbt”文件。</span></span></p>
</li>
<li>
<p><span><span>通過“<span> </span></span></span><strong><span><span>打開最近的世界”</span></span></strong><span><span>菜單項，可以從子菜單中顯示的列表中選擇一個最近打開的“ .wbt”文件，以重新打開該文件。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>打開示例世界”</span></span></strong><span><span>菜單項將打開一個對話框，列出所有可用的示例世界，在其中可以通過在搜索字段中輸入文件名或其中的一部分來搜索要加載的特定“ .wbt”文件。</span></span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/save-button.png" width="26"/><span><span>“<span> </span></span></span><strong><span><span>保存世界”</span></span></strong><span><span>菜單項（和按鈕）使用當前文件名（顯示在主窗口頂部的文件名）保存當前世界。</span><span>在每個</span></span><code>Save</code><span><span>.wbt文件的內容上都將被覆蓋，Webots不會創建任何備份副本，因此，您應謹慎使用此按鈕，並最終手動進行安全副本。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>另存為...”</span></span></strong><span><span>菜單項（和按鈕）使用用戶輸入的新文件名保存當前世界。</span><span>請注意，“。wbt”文件應始終保存在Webots項目目錄以及“ worlds”子目錄中，否則將無法重新打開該文件。</span></span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/revert-button.png" width="26"/><span><span>“<span> </span></span></span><strong><span><span>重新加載世界”</span></span></strong><span><span>菜單項（和按鈕）從已保存的版本重新加載當前世界，並從頭開始重新進行仿真。</span></span></p>
<span><span><img alt="" height="97" src="/images/注意.JPG" width="894"/></span></span></li>
</ul>
<p><span style="background-color: #ffffff;">  <img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/reset-simulation-button.png" width="26"/><span><span> 述</span></span><strong><span><span>復位仿真</span></span></strong><span><span>菜單項目（和按鈕）恢復模擬的初始狀態。</span><span>仿真並沒有像重新加載一樣完全被破壞和重建，但是所有節點的初始狀態都得以恢復，這要快得多。</span></span></span></p>
<p><span style="background-color: #ffffff;"><span><span><img alt="" height="515" src="/images/注意1.JPG" width="724"/></span></span></span></p>
<ul>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/new-button.png" width="26"/><span>“<span> </span></span><strong><span>新建文本文件”</span></strong><span>菜單項（和按鈕）在文本編輯器中打開一個空文本文件。</span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/open-button.png" width="26"/><span>“<span> </span></span><strong><span>打開文本文件...”</span></strong><span>菜單項（和按鈕）打開一個文件選擇對話框，該對話框允許您選擇要加載的文本文件（例如“ .java”文件）。</span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/save-button.png" width="26"/><span>“<span> </span></span><strong><span>保存文本文件”</span></strong><span>菜單項（和按鈕）將保存當前文本文件。</span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/save_as-button.png" width="26"/><span>“<span> </span></span><strong><span>將文本文件另存為...”</span></strong><span>菜單項（和按鈕）使用用戶輸入的新文件名保存當前文本文件。</span></p>
</li>
<li>
<p><span>將</span><strong><span>保存所有文本文件</span></strong><span>菜單項保存所有打開的和未保存的文本文件。</span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/revert-button.png" width="26"/><span>“<span> </span></span><strong><span>還原文本文件”</span></strong><span>菜單項（和按鈕）從保存的版本中重新加載文本文件。</span></p>
</li>
<li>
<p><span>“<span> </span></span><strong><span>打印預覽...”</span></strong><span>菜單項打開一個窗口，可讓您管理頁面佈局，以便從文本編輯器中打印文件。</span></p>
</li>
<li>
<p><span>“<span> </span></span><strong><span>打印...”</span></strong><span>菜單項打開一個窗口，使您可以打印文本編輯器的當前文件。</span></p>
</li>
<li>
<p><span>在</span><strong><span>導入VRML97 ...</span></strong><span>菜單項，在現場樹的末尾添加VRML97對象。這些對象來自您必須指定的VRML97文件。此功能對於導入在3D建模程序中建模的複雜形狀，然後導出到VRML97（以前稱為VRML 2.0）非常有用。大多數3D建模軟件，例如3D Studio Max，Maya，AutoCAD，Pro Engineer，AC3D或Art Of Illusion，都包含VRML97（或VRML 2.0）導出功能。請注意，Webots無法以VRML 1.0格式導入文件。導入後，這些對象將在場景樹的底部顯示為</span><a href="https://cyberbotics.com/doc/reference/group"><span>Group</span></a><span>，</span><a href="https://cyberbotics.com/doc/reference/transform"><span>Transform</span></a><span>或</span><a href="https://cyberbotics.com/doc/reference/shape"><span>Shape</span></a><span>節點。然後，您可以將這些對象轉換為Webots節點（例如</span><a href="https://cyberbotics.com/doc/reference/solid"><span>Solid</span></a><span>，</span><a href="https://cyberbotics.com/doc/reference/robot"><span>Robot</span></a><span>等），或將它們剪切並粘貼到</span><code>children</code><span>現有Webots節點列表中。</span></p>
</li>
<li>
<p><span>該</span><strong><span>出口VRML97 ...</span></strong><span>項目讓您當前載入世界保存為“.WRL”的文件，符合VRML97標準。反過來，可以使用任何VRML97查看器和大多數3D建模軟件打開此類文件。</span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/screenshot-button.png" width="26"/><span>使用</span><strong><span>“截取屏幕截圖...”</span></strong><span>項可以截取Webots中當前視圖的截屏。它會打開一個文件對話框，將當前視圖另存為PNG或JPG圖像。</span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/movie-button.png" width="26"/><span>在</span><strong><span>製作電影...</span></strong><span>項允許你創建MPEG電影（Linux和MacOS）或AVI動畫（Windows）中。電影錄製開始後，將在中更改此項</span><code>Stop Movie...</code><span>。在錄製期間，可以更改運行模式並暫停模擬。但是，僅在Webots步驟期間捕獲幀，而在暫停模擬時不捕獲。除了選擇影片的分辨率和壓縮質量外，還可以通過設置動畫來以加速模式或慢動作記錄模擬。</span><code>Video acceleration</code><span>彈出對話框中的值。如果視頻加速度值小於1，則錄製的動畫將比模擬慢。最大減慢速度，即最小加速度值，是由模擬的基本時間步長定義的，因為不可能以比模擬更新率更高的幀率進行記錄。為了增加最大的減慢速度，您應該減少仿真的基本時間步長。選中視頻字幕選項將在電影的右上角顯示加速度值。</span></p>
</li>
<li><span><img alt="" height="505" src="/images/製作電影對話框.JPG" width="441"/></span></li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>導出HTML5模型...”</span></span></strong><span><span>項允許您將當前世界導出為交互式3D“ .html”文件。</span><span>您可以在</span></span><a class="dynamicLoad" href="https://cyberbotics.com/doc/guide/web-scene"><span><span>本節中</span></span></a><span><span>獲得有關此主題的更多信息</span><span>。</span></span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/animation-button.png" width="26"/><span><span>“<span> </span></span></span><strong><span><span>製作HTML5動畫...”</span></span></strong><span><span>項使您可以將模擬記錄為3D動畫並將其發佈在HTML5網頁上。</span><span>開始動畫錄製後，此項目將更改為</span></span><code>Stop HTML5 Animation...</code><span><span>，可用於停止動畫錄製。</span><span>您可以在</span></span><a class="dynamicLoad" href="https://cyberbotics.com/doc/guide/web-animation"><span><span>本節中</span></span></a><span><span>獲得有關此主題的更多信息</span><span>。</span></span></p>
</li>
<li>
<p><strong><span><span>退出將</span></span></strong><span><span>終止當前的模擬並關閉Webot。</span></span></p>
<span><img alt="" height="62" src="/images/注意4.JPG" width="791"/></span><strong></strong><strong>編輯菜單</strong></li>
<li>編輯菜單提供了常用的文本編輯功能，可操縱在“ <em>文本”編輯器中</em>打開的<em>文件</em>，例如“複製”，“粘貼”，“剪切”等。</li>
</ul>
<h6><strong>查看菜單</strong></h6>
<p><span>使用“<span> </span></span><strong><span>查看”</span></strong><span>菜單可以控制模擬窗口中的查看。</span></p>
<ul>
<li>
<p><span><span>的</span></span><strong><span><span>跟隨對象</span></span></strong><span><span>子菜單可固定的（靜態）視點和跟隨移動對象（通常是一個機器人）的視點之間切換。</span><span>如果希望視點跟隨對象，則首先需要用鼠標選擇對象，然後根據所需的以下行為檢查子菜單中的一項。</span><span>有關不同以下行為的更多信息，</span><span>請參考</span></span><a href="https://cyberbotics.com/doc/reference/viewpoint"><span><span>Viewpoint</span></span></a><span><span>文檔。</span></span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/restore_viewpoint.png" width="26"/><span><span>加載或還原文件後，</span><span>“<span> </span></span></span><strong><span><span>還原</span></span><a href="https://cyberbotics.com/doc/reference/viewpoint"><span><span>視點”</span></span></a></strong><span><span>項會將視點的位置和方向恢復為其初始設置。</span><span>當您在場景中導航時迷路並想要返回原始視點時，此功能非常方便。</span></span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/move_viewpoint_to_object_button.png" width="26"/><span> </span><strong><span><span>將視點移至對象</span></span></strong><span><span>會將視點移至中心並在選定節點上縮放。</span><span>如果所選項目是字段，則將定位上級父節點。</span><span>該對象將位於3D視圖的中心，並且將完全可見。</span></span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/front_view.png" width="26"/><span><span>在</span></span><strong><span><span>更改視圖</span></span></strong><span><span>子菜單移動視點對準它在任何所選擇的對象周圍的世界六大對齊軸。</span><span>如果未選擇任何對象，則視點將以世界原點為中心。</span><span>可用的選項為</span></span><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/front_view.png" width="26"/><span> </span><strong><span><span>前視圖</span></span></strong><span><span>，</span></span><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/back_view.png" width="26"/><span> </span><strong><span><span>後視圖</span></span></strong><span><span>，</span></span><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/left_view.png" width="26"/><span> </span><strong><span><span>左視圖</span></span></strong><span><span>，</span></span><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/right_view.png" width="26"/><span> </span><strong><span><span>右視圖</span></span></strong><span><span>，</span></span><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/top_view.png" width="26"/><span> </span><strong><span><span>頂視圖</span></span></strong><span><span>和</span></span><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/bottom_view.png" width="26"/><span> </span><strong><span><span>底視圖</span></span></strong><span><span>。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>全屏”</span></span></strong><span><span>項啟用和禁用在整個屏幕上顯示3D窗口。</span></span></p>
</li>
<li>
<p><span><span>該</span></span><strong><span><span>虛擬現實耳機</span></span></strong><span><span>子菜單允許你使用虛擬現實的耳機，如HTC萬歲或Oculus Rift以查看模擬：</span></span></p>
<ul>
<li><span><span>將</span></span><strong><span><span>啟用</span></span></strong><span><span>選項允許你切換模擬視圖耳機。</span></span></li>
<li><span><span>“<span> </span></span></span><strong><span><span>跟踪頭戴式耳機位置”</span></span></strong><span><span>和“<span> </span></span></span><strong><span><span>跟踪頭戴式耳機方向”</span></span></strong><span><span>項目指定是否應跟踪頭戴式耳機的位置和方向並將其應用於視點。</span></span></li>
<li><span><span>“<span> </span></span></span><strong><span><span>查看左眼”</span></span></strong><span><span>，“<span> </span></span></span><strong><span><span>查看右眼”</span></span></strong><span><span>和“<span> </span></span></span><strong><span><span>空視圖”</span></span></strong><span><span>單選按鈕使您可以選擇在模擬視圖中應顯示的內容。</span><span>您可以看到左眼圖像，右眼圖像或什麼都看不到。</span></span></li>
<li><span><span>使用“<span> </span></span></span><strong><span><span>抗鋸齒”</span></span></strong><span><span>項可以在兩隻眼睛的圖像上啟用抗鋸齒（請注意，抗鋸齒會降低仿真速度）。</span></span></li>
<li><span></span><a class="dynamicLoad" href="https://cyberbotics.com/doc/guide/computer-peripherals"><span><span>此處</span></span></a><span><span>介紹耳機的安裝過程</span><span>。</span></span><span><span></span></span><span><span></span></span></li>
<li><span><span><img alt="" height="76" src="/images/注意5.JPG" width="746"/></span></span><span><span></span></span></li>
<li>
<p><span><span>通過“<span> </span></span></span><strong><span><span>投影”</span></span></strong><span><span>單選按鈕組，可以在“<span> </span></span></span><strong><span><span>透視投影”</span></span></strong><span><span>（默認）和“<span> </span></span><span>Webots模擬”窗口的“<span> </span></span></span><strong><span><span>正投影”</span></span></strong><span><span>模式</span><span>之間進行選擇</span><span>。</span><span>該</span></span><em><span><span>透視</span></span></em><span><span>模式對應於天然投影：其中所述更遠的對象是從觀察者，較小它出現在圖像中。</span><span>使用</span></span><em><span><span>正交</span></span></em><span><span>投影時，與查看者的距離不會影響物體的大小。</span><span>此外，在</span></span><em><span><span>正交</span></span></em><span><span>模式下，模型中平行的線在屏幕上平行繪製，因此，此投影有時在建模階段很有用。</span><span>在</span></span><em><span><span>正交</span></span></em><span><span>模式下</span><span>不會渲染陰影</span><span>。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>渲染”</span></span></strong><span><span>單選按鈕組使您可以在“<span> </span></span></span><strong><span><span>普通渲染”</span></span></strong><span><span>（默認）和“<span> </span></span><span>Webots模擬”<span> </span></span><span>的“<span> </span></span></span><strong><span><span>線框”</span></span></strong><span><span>模式</span><span>之間進行選擇</span><span>。</span><span>在</span></span><em><span><span>普通渲染</span></span></em><span><span>模式下，對像以其幾何面，材質，顏色和紋理進行渲染，其方式與通常用眼睛或照相機看到的方式相同。</span><span>在</span></span><em><span><span>線框渲染</span></span></em><span><span>模式下，只有可呈現圖元的段被渲染。</span><span>此模式對於調試網格很有用。</span><span>如果</span></span><em><span><span>線框渲染</span></span></em><span><span>模式和</span></span><code>View / Optional Rendering / Show All Bounding Objects</code><span><span>切換按鈕均被激活，則僅繪製邊界對象（不渲染可渲染圖元）。</span><span>這可用於調試衝突檢測問題。</span></span></p>
</li>
<li>
<p><span><span>在</span></span><strong><span><span>可選的渲染</span></span></strong><span><span>子菜單，可以顯示或隱藏，補充信息。</span><span>這些渲染僅顯示在主渲染中，並隱藏在機器人攝像機中。</span><span>它們用於更好地了解模擬的行為：</span></span></p>
<ul>
<li>
<p><span><span>使用“<span> </span></span></span><strong><span><span>顯示坐標系”，</span></span></strong><span><span>可以將3D窗口右下角的全局坐標系顯示或隱藏為分別代表x，y和z軸的紅色，綠色和藍色箭頭。</span></span></p>
</li>
<li>
<p><span><span>使用“<span> </span></span></span><strong><span><span>顯示所有邊界對象”，</span></span></strong><span><span>可以顯示或隱藏所有邊界對象（在</span><span>每個</span><em><span>Solid</span></em><span>節點</span><span>的</span></span><em><span><span>boundingObject</span></span></em><span><span>字段中</span><span>定義</span><span>）。</span><span>邊界對象由白線表示。</span><span>當發生碰撞時，這些線變為玫瑰，而當實體處於空閒狀態（即，它靜止不與任何其他活動的實體相互作用）時，這些線變為藍色。</span></span><em><span></span></em><span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>顯示接觸點”</span></span></strong><span><span>使您可以顯示或隱藏由碰撞檢測引擎生成的接觸點。</span><span>沒有示出沒有產生相應的接觸力的接觸點。</span><span>接觸力僅對使用物理模擬的對像生成（</span><span>需要</span></span><a href="https://cyberbotics.com/doc/reference/physics"><span><span>物理</span></span></a><span><span>節點）。</span><span>需要考慮此操作的步驟。</span></span></p>
</li>
<li>
<p><span><span>使用</span></span><strong><span><span>顯示連接器軸</span></span></strong><span><span>可以顯示或隱藏連接器軸。</span><span>旋轉對齊方式顯示為黑色，而y和z軸分別顯示為綠色和藍色。</span></span></p>
</li>
<li>
<p><span><span>使用“<span> </span></span></span><strong><span><span>顯示關節軸”</span></span></strong><span><span>可以顯示或隱藏關節軸。</span><span>關節軸用黑線表示。</span></span></p>
</li>
<li>
<p><span><span>所述</span></span><strong><span><span>顯示測距儀平截頭體</span></span></strong><span><span>，可以顯示或隱藏，OpenGL的平截頭體剔除和場景中的每個測距儀所記錄的圖像，使用黃色線框。</span><span>如果測距儀設備被禁用或第一張圖像尚不可用，則視錐將以灰色繪製。</span><span>OpenGL剔除視錐是與測距儀視場相對應的截頂金字塔。</span><span>記錄的圖像顯示在視錐台所描述的平面上，其距離對應於距設備中心的測距儀的最小範圍。</span><span>有關此概念的更多信息，請參見OpenGL文檔。</span></span></p>
</li>
<li>
<p><span><span>使用“<span> </span></span></span><strong><span><span>顯示激光雷達路徑”</span></span></strong><span><span>，您可以使用青色線框顯示或隱藏場景中每個激光雷達的圖層（激光射線路徑）。</span><span>如果禁用了激光雷達設備或尚無法進行第一次測量，則將這些層繪製為灰色。</span></span></p>
</li>
<li>
<p><span><span>該</span></span><strong><span><span>展會激光雷達點雲</span></span></strong><span><span>，可以顯示或隱藏，對於每一個激光雷達點雲點雲模式下啟用的場景。</span><span>點雲由這些點本身的位置以及從激光雷達原點到這些點的光線（從藍色（頂層）到紅色（底層）的漸變）表示。</span><span>這種可選的渲染在計算上很昂貴，因此會大大降低仿真速度。</span><span>請注意，如果點雲包含超過2500個點，則不會顯示從激光雷達原點到該點的射線。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>顯示攝像機視錐”</span></span></strong><span><span>允許您使用洋紅色線框顯示或隱藏場景中每個攝像機的OpenGL消隱視錐和記錄的圖像。</span><span>如果禁用了相機設備或第一張圖像尚不可用，則視錐將以灰色繪製。</span><span>OpenGL剔除視錐是與攝像機視場相對應的截頂金字塔。</span><span>由於遠端平面設置為無窮大，因此未顯示金字塔的背面。</span><span>記錄的圖像顯示在相機的近平面上。</span><span>有關此概念的更多信息，請參見OpenGL文檔。</span></span></p>
</li>
<li>
<p><span><span>所述</span></span><strong><span><span>顯示DistanceSensor射線</span></span></strong><span><span>，可以顯示或隱藏，光線由距離傳感器設備鑄造。</span><span>這些光線繪製為紅線（在碰撞點之外變為綠色）。</span><span>它們的長度對應於設備的最大範圍。</span><span>如果距離傳感器設備被禁用或尚無法進行第一次測量，則光線將以灰色繪製。</span></span></p>
</li>
<li>
<p><span><span>所述</span></span><strong><span><span>顯示LightSensor射線</span></span></strong><span><span>，可以顯示或隱藏，光線鑄造由光傳感器裝置。</span><span>這些射線繪製為黃線。</span><span>如果禁用了光傳感器設備或尚無法進行第一次測量，則光線將以灰色繪製。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>顯示光位置”</span></span></strong><span><span>允許您顯示或隱藏</span></span><a href="https://cyberbotics.com/doc/reference/pointlight"><span><span>PointLight</span></span></a><span><span>和</span></span><a href="https://cyberbotics.com/doc/reference/spotlight"><span><span>SpotLight</span></span></a><span><span>燈</span><span>的位置</span><span>。<span> </span></span><span>沒有顯示</span></span><a href="https://cyberbotics.com/doc/reference/directionallight"><span><span>DirectionalLight</span></span></a><span><span>節點。<span> </span></span></span><a href="https://cyberbotics.com/doc/reference/pointlight"><span><span>PointLight</span></span></a><span><span>和</span></span><a href="https://cyberbotics.com/doc/reference/spotlight"><span><span>SpotLight</span></span></a><span><span>節點由被耀斑圍繞的彩色圓圈表示。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>顯示筆繪畫射線”</span></span></strong><span><span>使您可以顯示或隱藏筆設備繪畫的射線。</span><span>如果啟用繪畫，這些光線將繪製為紫線，否則繪製為灰線。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>顯示雷達視錐”</span></span></strong><span><span>允許您顯示或隱藏雷達視錐。</span><span>如果啟用了雷達設備，則視錐表將顯示為藍色，否則，如果禁用了雷達或尚無法進行首次測量，則視錐表將顯示為灰色。</span><span>雷達視錐表代表雷達可以在其中檢測目標的體積。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>顯示重心”</span></span></strong><span><span>使您可以顯示或隱藏具有非NULL<span> </span></span></span><a href="https://cyberbotics.com/doc/reference/physics"><span><span>物理</span></span></a><span><span>節點</span><span>的選定實體的全局重心</span><span>。</span><span>重心呈深藍色。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>顯示浮力中心”</span></span></strong><span><span>使您可以顯示或隱藏具有非NULL<span> </span></span></span><a href="https://cyberbotics.com/doc/reference/physics"><span><span>物理</span></span></a><span><span>節點</span><span>的選定實體的整體浮力中心</span><span>。</span><span>浮力中心以紫色渲染。</span></span></p>
</li>
<li>
<p><span><span>使用</span></span><strong><span><span>顯示支撐多邊形，</span></span></strong><span><span>可以顯示或隱藏具有非NULL<span> </span></span></span><a href="https://cyberbotics.com/doc/reference/physics"><span><span>物理</span></span></a><span><span>節點</span><span>的選定實體的支撐多邊形</span><span>。</span><span>所謂支撐多邊形，是指實體的接觸點的凸包在水平平面上的投影，該平麵包含最低的多邊形。</span><span>此外，如果質心在後面的平面中的投影位於支撐多邊形內（靜態平衡），則呈綠色，否則呈紅色。</span><span>此渲染選項僅可用於頂部沒有其他實體的實體。</span></span></p>
</li>
</ul>
</li>
<li>
<p><span><span>如果</span><span>啟用</span><span>了“<span> </span></span></span><strong><span><span>禁用選擇”</span></span></strong><span><span>選項，則它會阻止您在單擊3D窗口時更改所選的實體節點。</span><span>當您要更改視點而不修改場景樹中的可見字段和選定字段時，這在建模階段特別有用。</span></span></p>
</li>
<li>
<p><span><span>如果</span><span>啟用</span><span>了“<span> </span></span></span><strong><span><span>鎖定視點”</span></span></strong><span><span>選項，則可以阻止您</span><span>在3D窗口上拖動鼠標或移動鼠標滾輪時</span><span>更改“<span> </span></span></span><a href="https://cyberbotics.com/doc/reference/viewpoint"><span><span>視點”</span></span></a><span><span>節點</span><span>的位置和方向</span><span>。</span><span>當您不想意外更改視點的位置和方向時，此功能特別有用。</span></span></p>
</li>
<li><span><span><img alt="" height="79" src="/images/注意6.JPG" width="789"/></span></span><span><span></span></span>
<h6><strong>模擬菜單</strong></h6>
</li>
<li>
<p><span>該</span><strong><span>模擬</span></strong><span>菜單用於控制模擬模式。</span></p>
<ul>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/pause-button.png" width="26"/><span><span>在</span></span><strong><span><span>暫停</span></span></strong><span><span>菜單項（和按鈕）暫停仿真。</span></span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/step-button.png" width="26"/><span><span>“<span> </span></span></span><strong><span><span>步驟”</span></span></strong><span><span>菜單項（和按鈕）執行模擬的一個基本時間步。</span><span>該步驟的持續時間</span><span>在</span><a href="https://cyberbotics.com/doc/reference/worldinfo"><span>WorldInfo</span></a><span>節點</span><span>的</span></span><strong><span><span>basicTimeStep</span></span></strong><span><span>字段中</span><span>定義</span><span>，可以在場景樹窗口中進行調整以滿足您的需求。</span></span><a href="https://cyberbotics.com/doc/reference/worldinfo"><span></span></a><span></span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/realtime-button.png" width="26"/><span><span>該</span></span><strong><span><span>實時</span></span></strong><span><span>菜單項（和按鈕），直到它被中斷運行在實時仿真</span></span><code>Pause</code><span><span>或</span></span><code>Step</code><span><span>。</span><span>在運行模式下，場景的3D顯示每</span></span><em><span><span>n個</span></span></em><span><span>基本時間步</span><span>刷新一次</span><span>，其中</span></span><em><span><span>n</span></span></em><span></span><code>displayRefresh</code><span><span>在</span></span><a href="https://cyberbotics.com/doc/reference/worldinfo"><span><span>WorldInfo</span></span></a><span><span>節點</span><span>的</span><span>字段中</span><span>定義</span><span>。</span></span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/run-button.png" width="26"/><span><span>“<span> </span></span></span><strong><span><span>運行”</span></span></strong><span><span>菜單項（和按鈕）類似於</span></span><code>Real-time</code><span><span>，除了它運行得盡可能快。</span></span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/fast-button.png" width="26"/><span><span>的</span></span><strong><span><span>快速</span></span></strong><span><span>菜單項目（和按鈕）是一樣</span></span><code>Run</code><span><span>，不同的是沒有圖形渲染被執行。</span><span>由於禁用了圖形渲染（黑屏），因此可以加快仿真速度，因此非常適合CPU密集型仿真（遺傳算法，視覺，學習等）。</span></span></p>
<strong>構建菜單</strong></li>
<li>在生成菜單提供的功能，以編譯（或交叉編譯）控制器的代碼。<a class="dynamicLoad" href="https://cyberbotics.com/doc/guide/webots-built-in-editor">此處</a>將更詳細地描述構建菜單。 
<h6><strong>疊加菜單</strong></h6>
</li>
<li>
<p><strong><span>覆蓋”</span></strong><span>菜單提供特定於渲染設備覆蓋的操作（“<span> </span></span><a href="https://cyberbotics.com/doc/reference/camera"><span>相機”</span></a><span>，“<span> </span></span><a href="https://cyberbotics.com/doc/reference/display"><span>顯示”</span></a><span>，“”<span> </span></span><code>Rangefinder</code><span>）。僅當在3D窗口中選擇了機械手或模擬中只有一個機械手時，此菜單的某些操作才有效：</span></p>
<ul>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>攝像機設備”</span></span></strong><span><span>子菜單包含所選機器人及其後代機器人的所有攝像機設備的列表，並允許用戶通過選中或取消選中相應項目來顯示或隱藏單個攝像機覆蓋圖像。</span><span>相機覆蓋層與顯示覆蓋層不同，因為它們具有洋紅色邊框。</span><span>請注意，如果</span></span><code>Hide All Camera Overlays</code><span><span>選中</span><span>該</span><span>項目，則與</span></span><code>Camera Devices</code><span><span>菜單項</span><span>的狀態無關，攝像頭設備的疊加層在3D視圖中將不可見</span><span>。</span><span>一</span></span><code>Camera Devices</code><span><span>，如果在外部窗口通過雙擊它顯示的疊加層的紋理菜單項將被禁用。</span></span></p>
</li>
<li>
<p><span><span>所述</span></span><strong><span><span>測距儀設備</span></span></strong><span><span>子菜單包含所有選定的機器人的測距儀設備和其後代機器人的列表，並讓用戶顯示或隱藏由選中或取消選中相應的項的單測距儀的疊加圖像。</span><span>測距儀疊加層與照相機疊加層不同，因為它們具有黃色邊框。</span><span>請注意，如果</span></span><code>Hide All RangeFinder Overlays</code><span><span>選中</span><span>該</span><span>項目，則與</span></span><code>RangeFinder Devices</code><span><span>菜單項</span><span>的狀態無關，在3D視圖中將不會顯示測距儀設備覆蓋圖</span><span>。</span><span>一</span></span><code>RangeFinder Devices</code><span><span>，如果在外部窗口通過雙擊它顯示的疊加層的紋理菜單項將被禁用。</span></span></p>
</li>
<li>
<p><span><span>所述</span></span><strong><span><span>顯示設備</span></span></strong><span><span>的子菜單包含所選機器人的所有的顯示設備和其後代機器人的列表，並讓通過檢查或取消選中相應的項目的用戶顯示或隱藏單個顯示疊加圖像。</span><span>顯示覆蓋圖與相機覆蓋圖不同，因為其青色邊框。</span><span>請注意，如果</span></span><code>Hide All Display Overlays</code><span><span>選中</span><span>該</span><span>項目，則顯示設備覆蓋圖在3D視圖中將不可見，而與</span></span><code>Display Devices</code><span><span>菜單項</span><span>的狀態無關</span><span>。</span><span>一</span></span><code>Display Devices</code><span><span>，如果在外部窗口通過雙擊它顯示的疊加層的紋理菜單項將被禁用。</span></span></p>
</li>
</ul>
<p><span><span>另一方面，以下各項始終處於活動狀態，並適用於世界上所有的機器人：</span></span></p>
<ul>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>隱藏所有攝像機覆蓋物”</span></span></strong><span><span>選項可獨立於</span></span><code>Camera Devices</code><span><span>子菜單中</span><span>設置的特定機器人設備選項，在3D視圖中隱藏所有攝像機設備覆蓋物</span><span>。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>隱藏所有RangeFinder疊加層”</span></span></strong><span><span>選項獨立於</span></span><code>RangeFinder Devices</code><span><span>子菜單中</span><span>設置的特定機器人的設備選項，在3D視圖中隱藏所有相機設備的疊加層</span><span>。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>隱藏所有顯示覆蓋圖”</span></span></strong><span><span>選項可獨立於</span></span><code>Display Devices</code><span><span>子菜單中</span><span>設置的特定機器人的設備選項，隱藏3D視圖中的所有顯示設備覆蓋圖</span><span>。</span></span></p>
<strong>工具菜單</strong></li>
<li>
<p><span>在</span><strong><span>工具</span></strong><span>菜單可以打開各種Webots窗口。</span></p>
<ul>
<li>
<p><span><span>在</span></span><strong><span><span>3D視圖</span></span></strong><span><span>菜單項顯示或隱藏3D窗口，並允許您與3D模擬互動。</span></span></p>
</li>
<li>
<p><span><span>該</span></span><strong><span><span>場景樹</span></span></strong><span><span>菜單項打開</span></span><code>Scene Tree</code><span><span>，可以在其中編輯虛擬世界的窗口。</span><span>或者，也可以雙擊主窗口中的某些對象：這將自動打開“場景樹”，並選擇相應的對象。</span></span></p>
</li>
<li>
<p><span><span>在</span></span><strong><span><span>文本編輯器</span></span></strong><span><span>菜單項打開Webots文本編輯器。</span><span>該編輯器可用於編輯和編譯控制器源代碼。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>控制台”</span></span></strong><span><span>菜單項將打開“ Webots控制台”，這是一個只讀控制台，用於顯示Webots錯誤消息和控制器輸出。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>文檔”</span></span></strong><span><span>菜單項顯示或隱藏脫機“ Webots”文檔窗口。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>還原佈局”</span></span></strong><span><span>菜單項可還原主窗口面板的出廠佈局。</span></span></p>
</li>
<li>
<p><span><span>該</span></span><strong><span><span>清除控制台</span></span></strong><span><span>菜單項清除控制台。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>編輯物理插件”</span></span></strong><span><span>菜單項將在文本編輯器中打開</span><strong><span>物理插件</span></strong><span>的源代碼。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>首選項”</span></span></strong><span><span>項將彈出</span></span><a class="dynamicLoad" href="https://cyberbotics.com/doc/guide/preferences"><span><span>本節中</span></span></a><span><span>描述的窗口</span><span>。</span></span></p>
<strong>嚮導菜單</strong></li>
<li>
<p><span>該</span><strong><span>嚮導</span></strong><span>菜單可以更容易地創建新的項目和新的控制器。</span></p>
<ul>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>新建項目目錄...”</span></span></strong><span><span>菜單項首先提示您選擇文件系統位置，然後創建一個項目目錄。</span><span>項目目錄包含幾個子目錄，這些子目錄用於存儲與特定Webots項目相關的文件，即世界文件，控制器文件，數據文件，插件等。Webots會記住當前項目目錄，並自動從中打開並保存任何類型的文件。當前項目目錄的相應子目錄。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>New Robot Controller ...”</span></span></strong><span><span>菜單項允許您創建新的控制器程序。</span><span>首先將提示您在C，C ++，Java，Python或</span></span><em><span><span>MATLAB<span> </span></span></span></em><sup><span><span>TM</span></span></sup><span><span>控制器</span><span>之間進行選擇</span><span>。</span><span>如果您在Windows上選擇C或C ++，Webots將為您提供創建Makefile / gcc項目或Visual Studio項目的可能性。</span><span>然後，Webots將要求您輸入控制器的名稱，最後它將在當前項目目錄中創建所有必需的文件（包括模板源代碼文件）。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>新建物理插件...”</span></span></strong><span><span>菜單項將使您可以為項目創建新的物理插件。</span><span>Webots要求您選擇一種編程語言（C或C ++）和新的物理插件的名稱。</span><span>然後，它將在當前項目中創建目錄，模板源代碼文件和Makefile。</span></span></p>
<strong>幫助菜單</strong></li>
<li>
<p><span>使用“<span> </span></span><strong><span>幫助”</span></strong><span>菜單可以更輕鬆地訪問文檔，支持和常規信息。</span></p>
<ul>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>關於...”</span></span></strong><span><span>項將打開一個</span></span><code>About...</code><span><span>顯示許可證信息</span><span>的</span><span>窗口。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>Webots導覽...”</span></span></strong><span><span>菜單項啟動了一個導覽，通過一系列示例演示Webots的功能。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>檢查更新...”</span></span></strong><span><span>項會彈出一個窗口，通知正在使用的Webots版本是否為最新版本，並在需要時提供下載最新版本的鏈接。</span></span></p>
</li>
<li>
<p><span><span>在</span></span><strong><span><span>OpenGL的信息...</span></span></strong><span><span>菜單項，為您提供有關當前OpenGL硬件和驅動程序的信息。</span><span>它可以用於診斷渲染問題。</span></span></p>
</li>
</ul>
<p><span><span>其餘菜單項以HTML頁面，PDF文檔等形式顯示各種信息。</span></span></p>
<strong>主工具欄</strong></li>
<li>
<p><span>主工具欄包含用於添加新節點對世界的按鈕，速度表（見本</span><a class="dynamicAnchor" href="https://cyberbotics.com/doc/guide/the-user-interface#speedometer-and-virtual-time"><span>節</span></a><span>）和快捷方式的項目</span><code>File</code><span>，</span><code>Simulation</code><span>和</span><code>View</code><span>菜單。</span></p>
<ul>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/show_scene_tree-button.png" width="26"/><span> </span><strong><span><span>隱藏/顯示場景樹</span></span></strong><span><span>：顯示或隱藏場景樹，並因此調整3D窗口的大小。</span></span></p>
</li>
<li>
<p><img alt="" height="26" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/add-button.png" width="26"/><span> </span><strong><span><span>添加</span></span></strong><span><span>：添加節點或對象。</span><span>對於節點，這會觸發一個對話框，使您可以從列表中選擇節點類型。</span><span>將使用默認值創建新節點，之後可以對其進行修改。</span><span>您只能插入適合相應字段的節點。</span><span>該對話框還可以通過單擊</span></span><strong><span><span>導入...</span></span></strong><span><span>按鈕</span><span>來加載先前導出的節點</span><span>。</span><span>有關如何導出節點的更多信息，請參見</span></span><a class="dynamicLoad" href="https://cyberbotics.com/doc/guide/the-scene-tree#field-editor"><span><span>此處</span></span></a><span><span>。</span></span></p>
<strong>車速表和虛擬時間</strong></li>
<li>速度計（請參見下<a class="dynamicAnchor" href="https://cyberbotics.com/doc/guide/the-user-interface#speedometer">圖</a>）指示計算機上模擬的速度。它顯示在主工具欄上，並指示仿真與實時相比運行的速度。換句話說，它代表虛擬時間的速度。如果速度計的值為2，則意味著您的計算機仿真的運行速度是相應真實機器人的兩倍。此信息在<code>Run</code>模式和<code>Fast</code>模式下均有效。注意：在逐步模式下運行模擬時，不會顯示模擬速度（<code>N/A</code>而是顯示)</li>
<li><img alt="" height="107" src="/images/車速表.JPG" width="300"/></li>
<li><span>在速度表的左側，使用以下格式顯示</span><em><span><span>虛擬時間</span></span></em><span><span>：</span></span><span><span></span></span></li>
<li><span><span><img alt="" height="63" src="/images/速度表虛擬時間.JPG" width="650"/></span></span></li>
<li>
<p><span>其中</span><em><span>H</span></em><span>是小時數（可以是幾位數字），</span><em><span>MM</span></em><span>是分鐘數，</span><em><span>SS</span></em><span>是秒數，</span><em><span>MMM</span></em><span>是毫秒數（請參見此</span><a class="dynamicAnchor" href="https://cyberbotics.com/doc/guide/the-user-interface#speedometer"><span>圖</span></a><span>）。如果車速表的值大於1，則虛擬時間的進度要快於實時時間。</span></p>
<p><span><span>可以</span><span>在場景樹窗口</span></span><code>basicTimeStep</code><span><span>的</span></span><a href="https://cyberbotics.com/doc/reference/worldinfo"><span><span>WorldInfo</span></span></a><span><span>節點</span><span>的</span><span>字段中</span><span>設置模擬的基本時間步長</span><span>。</span><span>它以虛擬時間毫秒錶示。</span><span>該時間步長的值定義了在</span></span><code>Step</code><span><span>模式</span><span>期間執行的時間步長</span><span>。</span><span>此步驟乘以</span></span><code>displayRefresh</code><span><span>同一</span></span><a href="https://cyberbotics.com/doc/reference/worldinfo"><span><span>WorldInfo</span></span></a><span><span>節點</span><span>的</span><span>字段，</span><span>以定義刷新顯示的頻率。</span></span></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Preferences(首選項)</h3>
<p><span>可以通過對話框修改Webots首選項，該對話框可以從</span><code>Webots / Preferences</code><span>Mac上的菜單項打開，也可以從</span><code>Tools / Preferences</code><span>其他操作系統上的菜單項打開。</span></p>
<p><span><span>該對話框分為多個選項卡。</span><span>以下每個小節對應於這些選項卡之一。</span></span></p>
<p>指數</p>
<ul id="index">
<li><a href="https://cyberbotics.com/doc/guide/preferences#general"><span><span>一般</span></span></a></li>
<li><a href="https://cyberbotics.com/doc/guide/preferences#opengl"><span><span>OpenGL</span></span></a></li>
<li><a href="https://cyberbotics.com/doc/guide/preferences#network"><span><span>網絡</span></span></a></li>
</ul>
<p><a class="anchor-link" href="https://cyberbotics.com/doc/guide/preferences#general"><span class="anchor-link-image"></span></a><span><span>一般</span></span></p>
<p><span><span>在</span></span><strong><span><span>常規</span></span></strong><span><span>選項卡包含有關應用程序的各種喜好。</span></span></p>
<ul>
<li><span><span>在</span></span><strong><span><span>語言</span></span></strong><span><span>選項允許您選擇Webots用戶界面（需要重新啟動）的語言。</span></span></li>
<li><span><span>在</span></span><strong><span><span>啟動模式</span></span></strong><span><span>，您可以選擇模擬的狀態時Webots開始（暫停，實時，運行速度快;看到</span></span><code>Simulation</code><span><span>菜單）。</span></span></li>
<li><span><span>所述</span></span><strong><span><span>編輯器的字體</span></span></strong><span><span>定義中Webots文本編輯器，並在控制台將要使用的字體。</span><span>建議選擇固定寬度的字體，以更好地顯示源代碼。</span><span>此首選項的默認值在Windows上為“ Consolas，10”，在Mac上為“ Courier，14”，在Linux上為“ Monospace”。</span></span></li>
<li><span><span>該</span></span><strong><span><span>線程數</span></span></strong><span><span>確定有多少線程可以通過Webots最大創建。</span><span>推薦值與計算機處理器的邏輯核心數匹配。</span><span>在某些特定情況下（例如，當另一個進程強烈需要其他內核時）降低此值可能很有趣。</span><span>目前，該值僅影響物理引擎速度和控制器編譯速度。</span><span>請注意，這是允許的最大線程數，但是實際使用的線程數是</span><a href="https://cyberbotics.com/doc/reference/worldinfo"><span>WorldInfo</span></a><span>節點</span><span>的</span></span><code>optimalThreadCount</code><span><span>字段中</span><span>定義的數量</span><span>。</span></span><a href="https://cyberbotics.com/doc/reference/worldinfo"><span></span></a><span></span></li>
<li><span><span>的</span></span><strong><span><span>Python的命令</span></span></strong><span><span>的Python命令由Webots開始一個Python控制器時調用定義。</span><span>默認值為</span></span><code>python</code><span><span>。</span><span>假定它</span></span><code>python</code><span><span>已安裝並且可以從命令行使用，那麼</span><span>它應該可以在大多數係統上工作</span><span>。</span><span>在某些系統上，</span></span><code>python3.7</code><span><span>例如，如果要使用此特定版本的Python啟動控制器，</span><span>將其設置為有用</span><span>。</span><span>請記住，此值可能會被</span></span><code>runtime.ini</code><span><span>Python控制器文件</span><span>的內容所覆蓋，該</span><span>文件可能會重新定義啟動該控制器的特定Python命令。</span></span></li>
<li><span><span>該</span></span><strong><span><span>額外項目的路徑</span></span></strong><span><span>定義了類似的用戶文件夾的路徑</span></span><code>WEBOTS_HOME/projects</code><span><span>文件夾。</span><span>該用戶文件夾應包含可在當前項目中使用的項目資源（例如PROTO節點，控制器，紋理等）。</span><span>它可能包含多個子文件夾，每個子文件夾都與一個子項目相關聯（應該遵守</span></span><a class="dynamicLoad" href="https://cyberbotics.com/doc/guide/the-standard-file-hierarchy-of-a-project"><span><span>一個項目</span></span></a><span><span>的</span><a class="dynamicLoad" href="https://cyberbotics.com/doc/guide/the-standard-file-hierarchy-of-a-project"><span>標准文件層次結構</span></a><span>）。</span><span>該文件夾還可以包含一個</span></span><code>default</code><span><span>項目，可用於定義通用控制器，紋理，聲音等。</span></span></li>
<li><span><span>“<span> </span></span></span><strong><span><span>警告：僅針對場景樹編輯</span></span></strong><span><span>顯示警告”複選框可防止Webot在通過更改視點，拖動，旋轉，施加力或通過修改當前世界退出，重新加載或加載新世界時顯示任何警告對話框窗口。施加到物體上的扭矩，或通過控制器修改世界。</span><span>但是，如果從場景樹修改了世界，它將仍然顯示警告。</span></span></li>
<li><span><span>該</span></span><strong><span><span>遙測：發送技術資料Webots developpers</span></span></strong><span><span>複選框允許Webots，以便發送匿名的技術數據Webots developpers以幫助改進軟件。</span></span><a class="dynamicLoad" href="https://cyberbotics.com/doc/guide/telemetry"><span><span>此處</span></span></a><span><span>提供了所有已發送數據的完整說明</span><span>。</span></span></li>
<li><span><span>該</span></span><strong><span><span>更新策略：檢查Webots更新在啟動時</span></span></strong><span><span>複選框允許Webots以檢查是否有新版本可供下載在每次啟動。</span><span>如果可用，對話框窗口將通知您。</span></span></li>
</ul>
<p><span><span>OpenGL</span></span></p>
<p><span><span>在</span></span><strong><span><span>OpenGL</span></span></strong><span><span>選項卡包含有關設置的3D渲染能力的偏好。</span><span>這些設置的默認參數可能會因係統的硬件和OpenGL功能而從一台計算機到另一台計算機。</span></span></p>
<ul>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>環境光遮擋”</span></span></strong><span><span>選項使您可以啟用</span></span><a href="http://iryoku.com/downloads/Practical-Realtime-Strategies-for-Accurate-Indirect-Occlusion.pdf" target="_blank"><span><span>GTAO</span></span></a><span><span>，這是3D視圖上屏幕空間環境光遮擋的一種現代形式。</span><span>此選項可在場景中實現更高水平的真實感，但性能成本卻不可忽略。</span><span>為了減輕這種情況，默認情況下將其設置為“中等”質量。</span><span>超高品質可提供最佳結果，但性能最高。</span></span></p>
</li>
<li>
<p><span></span><strong><span><span>Texture Quality</span></span></strong><span><span>（</span><strong><span>紋理質量）</span></strong><span>選項使您可以降低場景中所有紋理的分辨率，以節省GPU內存。</span><span>如果設置為</span></span><code>high</code><span><span>最大可用分辨率（即原始分辨率），將使用。</span><span>如果設置為</span></span><code>medium</code><span><span>，則將大於或等於1024的圖像分辨率除以2（分別考慮寬度和高度）。</span><span>如果設置為</span></span><code>low</code><span><span>，則將大於或等於512的圖像分辨率除以4。</span></span></p>
</li>
<li>
<p><span><span>“<span> </span></span></span><strong><span><span>禁用陰影”</span></span></strong><span><span>選項使您可以完全禁用3D視圖和“<span> </span></span></span><a href="https://cyberbotics.com/doc/reference/camera"><span><span>相機”</span></span></a><span><span>渲染中</span><span>的陰影</span><span>，無論</span></span><em><span><span>Light.castShadows</span></span></em><span><span>字段</span><span>的值</span><em><span>如何</span></em><span>。</span></span></p>
</li>
</ul>
<p><span><span>在全球範圍內，可以通過禁用此功能來提高性能，但另一方面，渲染更難於理解且不夠美觀。</span></span></p>
<ul>
<li><span><span>在</span></span><strong><span><span>禁用抗鋸齒</span></span></strong><span><span>選項，可以禁止在3D視圖和抗鋸齒</span></span><a href="https://cyberbotics.com/doc/reference/camera"><span><span>相機</span></span></a><span><span>渲染。</span><span>Webots使用的抗鋸齒算法是</span></span><a href="http://www.iryoku.com/smaa/" target="_blank"><span><span>SMAA 1x</span></span></a><span><span>。</span><span>我們觀察到一些舊的圖形硬件不支持有關抗鋸齒的OpenGL功能。</span><span>在這種情況下，最好禁用抗鋸齒功能。</span><span>否則，禁用抗鋸齒功能可能會導致性能略有提高，但會降低圖形保真度。</span></span></li>
</ul>
<p><a class="anchor-link" href="https://cyberbotics.com/doc/guide/preferences#network"><span class="anchor-link-image"></span></a><span><span>網絡</span></span></p>
<p><span><span>該</span></span><strong><span><span>網絡</span></span></strong><span><span>標籤，您可以手動配置HTTP代理，該代理Webots將利用在互聯網上訪問其許可證服務器。</span></span></p>
<ul>
<li>
<p><span><span>該</span></span><strong><span><span>代理服務器類型</span></span></strong><span><span>複選框允許您啟用或禁用襪子v5代理協議。</span></span></p>
</li>
<li>
<p><span><span>該</span></span><strong><span><span>代理主機</span></span></strong><span><span>字段，您可以設置代理服務器的主機名。</span></span></p>
</li>
<li>
<p><span><span>在</span></span><strong><span><span>代理端口</span></span></strong><span><span>字段允許您設置代理服務器使用的端口。</span></span></p>
</li>
<li>
<p><span><span>該</span></span><strong><span><span>代理的用戶名</span></span></strong><span><span>字段是可選的。</span><span>它允許您指定發送到代理服務器的用戶名。</span></span></p>
</li>
<li>
<p><span><span>該</span></span><strong><span><span>代理密碼</span></span></strong><span><span>字段是可選的，以及，並允許您指定發送到代理服務器的用戶密碼。</span></span></p>
</li>
</ul>
<p><span><span>更改代理配置後，建議重新啟動Webot，以確保正確考慮了更改。</span><span>如果清除“<span> </span></span></span><strong><span><span>代理主機名”</span></span></strong><span><span>字段，Webots將在下次啟動時嘗試檢索默認的系統代理。</span></span></p>
<h3>The Scene Tree(場景樹)</h3>
<p><span>如上一節所述，要訪問“場景樹窗口”，可以</span><code>Scene Tree</code><span>在</span><code>Tools</code><span>菜單中選擇，也可以按</span><code>Show Scene Tree</code><span>主工具欄中的按鈕。場景樹包含描述模擬世界（包括機器人和環境）及其圖形表示的信息。Webots的場景樹的結構類似於VRML97文件。它由節點列表組成，每個節點包含字段。字段可以包含值（文本字符串，數字值）或其他節點。</span></p>
<p><span><span>本節描述了“場景樹”的用戶界面，並概述了VRML97節點和Webots節點。</span></span></p>
<figure name="scene-tree-window"></figure>
<figure name="scene-tree-window"><img alt="" height="480" src="/images/場景樹用戶介面.JPG" width="263"/></figure>
<figure name="scene-tree-window">場景樹窗口</figure>
<p><span><span>場景樹具有上下文菜單，該上下文菜單包含許多有用的操作，具體取決於選擇，包括但不限於：剪切，複製和粘貼操作，將字段重置為其默認值，將</span></span><a href="https://cyberbotics.com/doc/reference/viewpoint"><span><span>視點</span></span></a><span><span>移至對象，設置</span></span><a href="https://cyberbotics.com/doc/reference/viewpoint"><span><span>視點</span></span></a><span><span>跟隨對象，或打開文檔查看器以查看所選節點的文檔。</span></span></p>
<p><span><span>此外，如果當前選擇是</span></span><a href="https://cyberbotics.com/doc/reference/robot"><span><span>Robot</span></span></a><span><span>節點（或後代，或</span></span><code>PROTO</code><span><span>基於</span></span><a href="https://cyberbotics.com/doc/reference/robot"><span><span>Robot的</span></span></a><span><span>實例</span><span>），則可以在文本編輯器中打開相應的機器人窗口或打開機器人的控制器。</span></span></p>
<p><br/><a class="anchor-link" href="https://cyberbotics.com/doc/guide/the-scene-tree#field-editor"><span class="anchor-link-image"></span></a><span><span>現場編輯</span></span></p>
<p><span><span>可以雙擊擴展節點。</span><span>選擇字段後，可以在“場景樹”的底部編輯其值。</span><span>雙擊或按</span></span><code>Enter</code><span><span>字段上</span><span>的</span><span>鍵將選擇字段編輯器面板的第一個可編輯項目。</span><span>可以通過在字段編輯器面板中的所有項目之間切換來將鍵盤焦點返回到“場景樹”。</span><span>對於文本字段，通過按鍵應用更改</span></span><code>Enter</code><span><span>。</span><span>這對於數字字段是相同的，但是向上和向下箭頭鍵也可以用於向上和向下調整值，並立即應用更改。</span><span>對於復選框，使用</span></span><code>Space</code><span><span>欄</span><span>更改值</span><span>。</span><span>應用的更改將立即反映在3D窗口中。</span><span>字段編輯器部分提供以下按鈕：</span></span></p>
<p><img alt="" height="306" src="/images/場景樹編輯.JPG" width="454"/></p>
<p>Webots節點編輯器</p>
<ul>
<li>
<p><strong><span><span>顯示調整大小手柄</span></span></strong><span><span>：顯示用於調整大小和縮放3D窗口中選定節點的手柄。</span><span>僅對“幾何”節點和“<span> </span></span></span><a href="https://cyberbotics.com/doc/reference/transform"><span><span>變換”</span></span></a><span><span>節點</span><span>派生的節點顯示此選項</span><span>。</span><span>對於過程性PROTO節點，僅當在模板語句中未使用調整大小或縮放所涉及的字段時才可用。</span></span></p>
</li>
</ul>
<h3>編成基礎(控制器編成,Python範例)</h3>
<p><em><strong><span>編程基礎</span></strong></em></p>
<p>This chapter introduces the basic concepts of programming with Webots. Webots controllers can be written in C/C++, Java, Python or<em>MATLAB</em><sup>TM</sup>.<span> </span></p>
<p>本章介紹使用<span>Webots</span>進行編程的基本概念。<span><span> </span>Webots</span>控制器可以用<span>C / C ++</span>，<span>Java</span>，<span>Python</span>或<em>MATLAB</em><sup>TM</sup>編寫。 </p>
<p><span>Besides their syntactic differences all these languages share the same low-level implementation.</span></p>
<p><span> </span>除了語法上的差異外，所有這些語言都共享相同的低階實現。</p>
<p><span> </span><span>As long as the sequence of function/method calls does not vary, every programming language will yield exactly the same simulation results.</span></p>
<p>只要函數<span>/</span>方法的調用順序不變，每種編程語言都會產生完全相同的仿真結果。</p>
<p>Hence, the concepts explained here with C examples also apply to C++, Java, Python and MATLAB.</p>
<p>因此，此處用<span>C</span>示例說明的概念也適用於<span>C ++</span>，<span>Java</span>，<span>Python</span>和<span>MATLAB</span>。</p>
<p><span>Controller Programming</span></p>
<p>控制器編程</p>
<p><span>Hello World Example</span></p>
<p><span>The tradition in computer science is to start with a "Hello World!" example. So here is a "Hello World!" example for a Webots controller:</span></p>
<p>你好世界範例</p>
<p>計算機科學的傳統始於“<span><span> </span>Hello World</span>！”。 例。 這就是“<span><span> </span>Hello World</span>！”<span><span> </span>Webots</span>控制器的範例：</p>
<p><img alt="" height="410" src="https://s40723118.github.io/cd2020/images/1.jpg" width="1058"/></p>
<p>This code repeatedly prints "Hello World!" to the standard output stream which is redirected to Webots console. The standard output and error streams are automatically redirected to Webots console for all Webots supported languages.</p>
<p>此代碼反复打印“ Hello World！”。 到標準輸出流，該輸出將重定向到Webots控制台。 對於所有Webots支持的語言，標準輸出和錯誤流將自動重定向到Webots控制台。</p>
<p>Webots C API (Application Programming Interface) is provided by regular C header files. These header files must be included using statements like #include &lt;webots/xyz.h&gt; where xyz represents the name of a Webots node in lowercase.</p>
<div class="tlid-input input">
<div class="source-wrap">
<div class="input-full-height-wrapper tlid-input-full-height-wrapper">
<div class="source-input">
<div class="source-footer-wrap source-or-target-footer">
<div class="source-footer">
<div class="speech-wrap source-or-target-footer-button left-positioned">
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" id="gt-speech" role="button" tabindex="0"><span class="jfk-button-img"></span></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="tlid-results-container results-container">
<div class="tlid-result result-dict-wrapper">
<div class="result tlid-copy-target">
<div class="text-wrap tlid-copy-target">
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span title="">Webots C API（應用程序編程接口）由常規C頭文件提供。</span><span> </span><span class="" title="">這些頭文件必須使用#include &lt;webots / xyz.h&gt;之類的語句包括在內，其中xyz表示小寫的Webots節點的名稱。</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">Like with any regular C code it is also possible to include the standard C headers, e.g. #include &lt;stdio.h&gt;. A call to the initialization wb_robot_init function is required before any other C API function call. </span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">像任何常規C代碼一樣，也可以包括標準C標頭，例如 #include &lt;stdio.h&gt;。 在調用任何其他C API函數之前，需要先調用初始化wb_robot_init函數。</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">This function initializes the communication between the controller and Webots. The wb_robot_cleanup function does the opposite: it closes the communication between the controller and Webots to terminate the controller smoothly. Note that the wb_robot_init and wb_robot_cleanup functions exist only in the C API, they do not have any equivalent in the other supported programming languages.</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">該功能初始化控制器和Webot之間的通信。 wb_robot_cleanup函數的作用與此相反：它關閉了控制器和Webot之間的通信，以平滑地終止控制器。 請注意，wb_robot_init和wb_robot_cleanup函數僅存在於C API中，在其他受支持的編程語言中沒有任何等效功能。</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">Usually the highest level control code is placed inside a for or a while loop. Within that loop there is a call to the wb_robot_step function. This function synchronizes the controller's data with the simulator. The wb_robot_step function needs to be present in every controller and it must be called at regular intervals, therefore it is usually placed in the main loop as in the above example.</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">通常，最高級別的控制代碼位於for或while循環內。 在該循環中，調用了wb_robot_step函數。 該功能使控制器的數據與模擬器同步。 wb_robot_step函數必須存在於每個控制器中，並且必須以規則的時間間隔調用，因此，如上例所示，通常將其放置在主循環中。</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">The value 32 specifies the duration of the control steps, i.e., the wb_robot_step function shall compute 32 milliseconds of simulation and then return. This duration specifies an amount of simulated time, not real (wall clock) time, so it may actually take 1 millisecond or one minute of real time, depending on the complexity of the simulated world.</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">值32指定控制步驟的持續時間，即wb_robot_step函數應計算32毫秒的仿真，然後返回。 此持續時間指定的是模擬時間量，而不是實際（牆上時鐘）時間，因此實際時間可能需要1毫秒或1分鐘，這取決於模擬世界的複雜性。</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>Note that in this "Hello World!" example, the exit condition of the </span><code>while</code><span><span> </span>loop is the return value of the<span> </span></span><code>wb_robot_step</code><span><span> </span>function. This function will indeed return<span> </span></span><code>-1</code><span><span> </span>when Webots terminates the controller (see<span> </span></span><a class="dynamicAnchor" href="https://cyberbotics.com/doc/guide/controller-programming#controller-termination">Controller Termination</a><span>). Therefore, in this example, the control loop will run as long as the simulation runs. When the loop exists, no further communication with Webots is possible and the only option is to confirm to Webots to close the communication by calling the<span> </span></span><code>wb_robot_cleanup</code><span><span> </span>function.</span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0">
<div class="tlid-input input">
<div class="source-wrap">
<div class="input-full-height-wrapper tlid-input-full-height-wrapper">
<div class="source-input">
<div class="source-footer-wrap source-or-target-footer">
<div class="source-footer">
<div class="speech-wrap source-or-target-footer-button left-positioned">
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" id="gt-speech" role="button" tabindex="0"><span class="jfk-button-img"></span></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="tlid-results-container results-container">
<div class="tlid-result result-dict-wrapper">
<div class="result tlid-copy-target">
<div class="result-header">
<div aria-label="收藏翻譯" class="starbutton jfk-button-flat jfk-button unstarred" data-tooltip="收藏翻譯" data-tooltip-align="t,c" role="button" tabindex="0">
<div class="jfk-button-img"></div>
</div>
</div>
<div class="text-wrap tlid-copy-target">
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span title="">請注意，在此“ Hello World！”中</span><span> </span><span class="" title="">例如，while循環的退出條件是wb_robot_step函數的返回值。</span><span> </span><span title="">當Webots終止控制器時，此函數的確會返回-1（請參閱控制器終止）。</span><span> </span><span class="" title="">因此，在此示例中，控制循環將在仿真運行期間一直運行。</span><span> </span><span class="" title="">當存在循環時，無法與Webots進行進一步的通信，並且唯一的選擇是通過調用wb_robot_cleanup函數來向Webots確認關閉通信。</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">Reading Sensors</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">讀數傳感器</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">Now that we have seen how to print a message to the console, we shall see how to read the sensors of a robot. The next example does continuously update and print the value returned by a DistanceSensor:</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title="">現在，我們已經了解瞭如何將消息打印到控制台，我們將看到如何讀取機器人的傳感器。 下一個示例確實不斷更新並打印由DistanceSensor返回的值：</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><img alt="" height="640" src="https://s40723118.github.io/cd2020/images/2.jpg" width="1056"/></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>As you can notice, prior to using a device, it is necessary to get the corresponding device tag (</span><code>WbDeviceTag</code><span>); this is done using the<span> </span></span><code>wb_robot_get_device</code><span><span> </span>function. The<span> </span></span><code>WbDeviceTag</code><span><span> </span>is an opaque type that is used to identify a device in the controller code. Note that the string passed to this function,<span> </span></span><em>"my_distance_sensor"</em><span><span> </span>in this example, refers to a device name specified in the robot description (".wbt" or ".proto" file). If the robot has no device with the specified name, this function returns 0.</span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>如您所見，在使用設備之前，有必要獲取相應的設備標籤（WbDeviceTag）。 這是使用wb_robot_get_device函數完成的。 WbDeviceTag是不透明的類型，用於在控制器代碼中標識設備。 請注意，在此示例中，傳遞給此函數的字符串“ my_distance_sensor”是指機械手描述中指定的設備名稱（“ .wbt”或“ .proto”文件）。 如果機器人沒有指定名稱的設備，則此函數返回0。</span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>Each sensor must be enabled before it can be used. If a sensor is not enabled it returns undefined values. Enabling a sensor is achieved by using the corresponding <code>wb_*_enable</code><span><span> </span>function, where the star (</span><code>*</code><span>) stands for the sensor type. Every<span> </span></span><code>wb_*_enable</code><span><span> </span>function allows to specify an update delay in milliseconds. The update delay specifies the desired interval between two updates of the sensor's data.</span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span>必須先啟用每個傳感器，然後才能使用它。 如果未啟用傳感器，它將返回未定義的值。 通過使用相應的wb _ * _ enable函數來啟用傳感器，其中星號（*）代表傳感器類型。 每個wb _ * _ enable函數均允許指定更新延遲（以毫秒為單位）。 更新延遲指定兩次傳感器數據更新之間的期望間隔。</span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span>In the usual case, the update delay is chosen to be similar to the control step (<code>TIME_STEP</code><span>) and hence the sensor will be updated at every<span> </span></span><code>wb_robot_step</code><span><span> </span>function call. If, for example, the update delay is chosen to be twice the control step then the sensor data will be updated every two<span> </span></span><code>wb_robot_step</code><span><span> </span>function calls: this can be used to simulate a slow device. Note that a larger update delay can also speed up the simulation, especially for CPU intensive devices like the<span> </span></span><a href="https://cyberbotics.com/doc/reference/camera">Camera</a><span>.</span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span><span></span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span><span>在通常情況下，更新延遲被選擇為與控制步驟（TIME_STEP）相似，因此傳感器將在每次wb_robot_step函數調用時進行更新。 例如，如果將更新延遲選擇為控制步驟的兩倍，則每兩個wb_robot_step函數調用將更新一次傳感器數據：這可用於模擬慢速設備。 請注意，較大的更新延遲也可以加快仿真速度，尤其是對於像相機這樣佔用大量CPU資源的設備而言。</span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span><span></span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span><span>On the contrary, it would be pointless to choose an update delay smaller than the control step, because it will not be possible for the controller to process the device's data at a higher frequency than that imposed by the control step. It is possible to disable a device at any time using the corresponding <code>wb_*_disable</code><span><span> </span>function. This may increase the simulation speed.</span></span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span><span><span></span></span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span><span><span>相反，選擇小於控制步驟的更新延遲將毫無意義，因為控制器將不可能以比控制步驟所施加的頻率更高的頻率來處理設備的數據。 使用對應的wb _ * _ disable函數可以隨時禁用設備。 這可以提高仿真速度。</span></span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span><span><span></span></span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0">
<p>The sensor value is updated during the call to the<span> </span><code>wb_robot_step</code><span> </span>function. The call to the<span> </span><code>wb_distance_sensor_get_value</code><span> </span>function retrieves the latest value.</p>
<p>Note that some device return vector values instead of scalar values, for example these functions:</p>
<p>在調用wb_robot_step函數期間，將更新傳感器值。 調用wb_distance_sensor_get_value函數可檢索最新值。</p>
<p>請注意，某些設備返回矢量值而不是標量值，例如，以下函數：</p>
<p><img alt="" height="86" src="https://s40723118.github.io/cd2020/images/3.jpg" width="498"/></p>
<p><span>Each function returns a pointer to three double values. The pointer is the address of an array allocated by the function internally. These arrays should never be explicitly deleted by the controller code. They will be automatically deleted when necessary. The array contains exactly three double values. Hence accessing the array beyond index 2 is illegal and may crash the controller. Finally, note that the array elements should not be modified, for this reason the pointer is declared as </span><em>const</em><span>. Here are correct examples of code using these functions:</span></p>
<p><span></span></p>
<p><span>每個函數都返回一個指向三個double值的指針。 指針是函數在內部分配的數組的地址。 這些數組絕不能由控制器代碼顯式刪除。 它們將在必要時自動刪除。 該數組恰好包含三個double值。 因此，訪問超出索引2的數組是非法的，並且可能使控制器崩潰。 最後，請注意，不應修改數組元素，因此，指針被聲明為const。 這是使用這些功能的正確代碼示例：</span></p>
<p><span><img alt="" height="500" src="https://s40723118.github.io/cd2020/images/4.jpg" width="1056"/></span></p>
<p><span>And here are incorrect examples:</span></p>
<p><span>這是不正確的範例：</span></p>
<p><span><img alt="" height="218" src="https://s40723118.github.io/cd2020/images/5.jpg" width="1056"/></span></p>
Using Actuators</div>
<div class="result-shield-container tlid-copy-target" tabindex="0">使用執行器</div>
<div class="result-shield-container tlid-copy-target" tabindex="0"></div>
<div class="result-shield-container tlid-copy-target" tabindex="0">
<p>The example below shows how to make a rotational motor oscillate with a 2 Hz sine signal.</p>
<p>Just like sensors, each Webots actuator must be identified by a<span> </span><code>WbDeviceTag</code><span> </span>returned by the<span> </span><code>wb_robot_get_device</code><span> </span>function. However, unlike sensors, actuators don't need to be expressly enabled; they actually don't have<span> </span><code>wb_*_enable</code><span> </span>functions.</p>
<p>以下示例顯示瞭如何使旋轉電機以2 Hz正弦信號振盪。</p>
<p>就像傳感器一樣，每個Webots執行器都必須由wb_robot_get_device函數返回的WbDeviceTag進行標識。 但是，與傳感器不同的是，無需明確啟用執行器。 他們實際上沒有wb _ * _ enable函數。</p>
<p><span>To control a motion, it is generally useful to decompose that motion in discrete steps that correspond to the control step. As before, an infinite loop is used here: at each iteration a new target position is computed according to a sine equation. The </span><code>wb_motor_set_position</code><span><span> </span>function stores a new position request for the corresponding rotational motor. Note that the<span> </span></span><code>wb_motor_set_position</code><span><span> </span>function stores the new position, but it does not immediately actuate the motor. The effective actuation starts on the next line, in the call to the<span> </span></span><code>wb_robot_step</code><span><span> </span>function.</span></p>
<p><span>為了控制運動，通常以與控制步驟相對應的離散步驟分解該運動。 如前所述，這裡使用了無限循環：在每次迭代中，根據正弦方程計算新的目標位置。 wb_motor_set_position函數存儲相應旋轉電機的新位置請求。 請注意，wb_motor_set_position函數存儲新位置，但不會立即啟動電動機。 有效的致動從對wb_robot_step函數的調用的下一行開始。</span></p>
<p><span>The <code>wb_robot_step</code><span><span> </span>function sends the actuation command to the<span> </span></span><a href="https://cyberbotics.com/doc/reference/rotationalmotor">RotationalMotor</a><span><span> </span>but it does not wait for the<span> </span></span><a href="https://cyberbotics.com/doc/reference/rotationalmotor">RotationalMotor</a><span><span> </span>to complete the motion (i.e. reach the specified target position); it just simulates the motor's motion for the specified number of milliseconds.</span></span></p>
<p><span><span>wb_robot_step函數將致動命令發送到RotationalMotor，但不等待RotationalMotor完成運動（即到達指定的目標位置）； 它只是在指定的毫秒數內模擬電動機的運動。</span></span></p>
<p><span><span><img alt="" height="721" src="https://s40723118.github.io/cd2020/images/6.jpg" width="1054"/></span></span></p>
<p><span><span>When the <code>wb_robot_step</code><span><span> </span>function returns, the motor has moved by a certain (linear or rotational) amount which depends on the target position, the duration of the control step (specified with the<span> </span></span><code>wb_robot_step</code><span><span> </span>function argument), the velocity, acceleration, force, and other parameters specified in the ".wbt" description of the<span> </span></span><code>Motor</code><span>.<span> </span></span></span></span></p>
<p><span><span><span>當wb_robot_step函數返回時，電機已移動了一定量（線性或旋轉），具體取決於目標位置，控制步驟的持續時間（由wb_robot_step函數參數指定），速度，加速度，力等 電動機的“ .wbt”描述中指定的參數。</span></span></span></p>
<p><span><span><span>For example, if a very small control step or a low motor velocity is specified, the motor will not have moved much when the <code>wb_robot_step</code><span><span> </span>function returns. In this case several control steps are required for the<span> </span></span><a href="https://cyberbotics.com/doc/reference/rotationalmotor">RotationalMotor</a><span><span> </span>to reach the target position. If a longer duration or a higher velocity is specified, then the motor may have fully completed the motion when the<span> </span></span><code>wb_robot_step</code><span><span> </span>function returns.</span></span></span></span></p>
<p><span><span><span><span>例如，如果指定了非常小的控制步長或較低的電動機速度，則當wb_robot_step函數返回時，電動機將不會移動太多。 在這種情況下，RotationalMotor需要幾個控制步驟才能達到目標位置。 如果指定了更長的持續時間或更高的速度，則當wb_robot_step函數返回時，電動機可能已完全完成運動。</span></span></span></span></p>
<p><span><span><span><span>Note that the <code>wb_motor_set_position</code><span><span> </span>function only specifies the<span> </span></span><em>desired</em><span><span> </span>target position. Just like with real robots, it is possible (in physics-based simulations only), that the<span> </span></span><a href="https://cyberbotics.com/doc/reference/rotationalmotor">RotationalMotor</a><span><span> </span>is not able to reach this position, because it is blocked by obstacles or because the motor's torque (</span><code>maxForce</code><span>) is insufficient to oppose gravity, etc.</span></span></span></span></span></p>
<p><span><span><span><span><span>請注意，wb_motor_set_position函數僅指定所需的目標位置。 就像真正的機器人一樣，RotationalMotor有可能（僅在基於物理的模擬中）無法到達此位置，原因是它被障礙物阻擋，或者因為電動機的扭矩（maxForce）不足以抵抗重力等。 </span></span></span></span></span></p>
<p><span><span><span><span><span>If you want to control the motion of several <a href="https://cyberbotics.com/doc/reference/rotationalmotor">RotationalMotors</a><span><span> </span>simultaneously, then you need to specify the desired position for each<span> </span></span><a href="https://cyberbotics.com/doc/reference/rotationalmotor">RotationalMotor</a><span><span> </span>separately, using the<span> </span></span><code>wb_motor_set_position</code><span><span> </span>function. Then you need to call the<span> </span></span><code>wb_robot_step</code><span><span> </span>function once to actuate all the<span> </span></span><a href="https://cyberbotics.com/doc/reference/rotationalmotor">RotationalMotors</a><span><span> </span>simultaneously.</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>如果要同時控制多個RotationalMotor的運動，則需要使用wb_motor_set_position函數分別為每個RotationalMotor指定所需的位置。 然後，您需要調用wb_robot_step函數一次以同時啟動所有RotationalMotor。</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>The "step" and "wb_robot_step" Functions</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>“步驟”和“ wb機器人步驟”功能</span></span></span></span></span></span></p>
<p>Webots uses two different time steps:</p>
<ul>
<li>The simulation step (specified in the Scene Tree:<span> </span><code>WorldInfo.basicTimeStep</code>)</li>
<li>The control step (specified as an argument of the<span> </span><code>wb_robot_step</code><span> </span>function for each robot)</li>
</ul>
<p>Webots使用兩個不同的時間步驟：</p>
<p>模擬步驟（在“場景樹”中指定：WorldInfo.basicTimeStep）<br/>控制步驟（指定為每個機器人的wb_robot_step函數的參數）</p>
<p><span>The simulation step is the value specified in </span><code>WorldInfo.basicTimeStep</code><span><span> </span>(in milliseconds). It indicates the duration of one step of simulation, i.e. the time interval between two computations of the position, speed, collisions, etc. of every simulated object. If the simulation uses physics (vs. kinematics), then the simulation step also specifies the interval between two computations of the forces and torques that need to be applied to the simulated rigid bodies.</span></p>
<p><span>模擬步驟是WorldInfo.basicTimeStep中指定的值（以毫秒為單位）。 它指示了一個模擬步驟的持續時間，即每個模擬對象的位置，速度，碰撞等兩次計算之間的時間間隔。 如果模擬使用物理學（相對於運動學），則模擬步驟還指定需要對模擬剛體施加力和扭矩的兩次計算之間的間隔。</span></p>
<p><span>The control step is the duration of an iteration of the control loop. It corresponds to the parameter passed to the <code>wb_robot_step</code><span><span> </span>function. The<span> </span></span><code>wb_robot_step</code><span><span> </span>function advances the controller time of the specified duration. It also synchronizes the sensors and actuators data with the simulator according to the controller time.</span></span></p>
<p><span><span>控制步驟是控制循環迭代的持續時間。 它對應於傳遞給wb_robot_step函數的參數。 wb_robot_step函數可將指定時間的控制器時間提前。 它還根據控制器時間將傳感器和執行器的數據與模擬器同步。</span></span></p>
<p><span><span>Every controller needs to call the <code>wb_robot_step</code><span><span> </span>function at regular intervals. If a controller does not call the<span> </span></span><code>wb_robot_step</code><span><span> </span>function, then the sensors and actuators won't be updated and the simulator will block (in synchronous mode only). Because it needs to be called regularly, the<span> </span></span><code>wb_robot_step</code><span><span> </span>function call is usually placed in the main loop of the controller.</span></span></span></p>
<p><span><span><span>每個控制器都需要定期調用wb_robot_step函數。 如果控制器未調用wb_robot_step函數，則不會更新傳感器和執行器，並且模擬器將阻塞（僅在同步模式下）。 由於需要定期調用，因此wb_robot_step函數調用通常位於控制器的主循環中。</span></span></span></p>
<p><span><span><span>The execution of a simulation step is an atomic operation: it cannot be interrupted. Hence a sensor measurement or a motor actuation can only take place between two simulation steps. For that reason the control step specified with each <code>wb_robot_step</code><span><span> </span>function calls must be a multiple of the simulation step. So, for example, if the simulation step is 16 ms, then the control step argument passed to the<span> </span></span><code>wb_robot_step</code><span><span> </span>function can be 16, 32, 64, 128, etc.</span></span></span></span></p>
<p><span><span><span><span>模擬步驟的執行是一項原子操作：不能中斷。 因此，傳感器測量或電機驅動只能在兩個模擬步驟之間進行。 因此，每個wb_robot_step函數調用指定的控制步驟必須是模擬步驟的倍數。 因此，例如，如果模擬步驟為16 ms，則傳遞給wb_robot_step函數的控制步驟參數可以為16、32、64、128等。</span></span></span></span></p>
<p><span><span><span><span>If the simulation is run in step-by-step mode, i.e., by clicking on the <strong>Step</strong><span><span> </span>button (see<span> </span></span><a class="dynamicLoad" href="https://cyberbotics.com/doc/guide/the-user-interface">The User Interface</a><span><span> </span>section), then a single step having the simulation step duration is executed. The following<span> </span></span><a class="dynamicAnchor" href="https://cyberbotics.com/doc/guide/controller-programming#synchronization-of-simulation-and-controller-steps">figure</a><span><span> </span>depicts in details the synchronization between the simulation status, the controller status and the step clicks.</span></span></span></span></span></p>
<p><span><span><span><span><span>如果仿真以逐步模式運行，即通過單擊“步進”按鈕（請參見“用戶界面”部分），則將執行具有仿真步長的單個步驟。 下圖詳細描述了仿真狀態，控制器狀態和步驟咔嗒聲之間的同步。</span></span></span></span></span></p>
<p><span><span><span><span><span><img alt="" height="400" src="https://s40723118.github.io/cd2020/images/7.png" width="275"/></span></span></span></span></span></p>
<p><span><span><span><span><span>At every step, all the commands before the <code>wb_robot_step</code><span><span> </span>function call statements are executed first and the simulation stops in the middle of the execution of the<span> </span></span><code>wb_robot_step</code><span><span> </span>function. Webots API functions are executed but they are applied to the simulation world only when calling the<span> </span></span><code>wb_robot_step</code><span><span> </span>function, that is when the controller process communicates with Webots process. When the simulation stops, the new simulation status has already been computed, the simulation time has been updated and the new sensors values are ready. Note that the first step includes the initialization too. So all the statements before the second<span> </span></span><code>wb_robot_step</code><span><span> </span>function call are executed.</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>在每個步驟中，首先執行wb_robot_step函數調用語句之前的所有命令，並且模擬在wb_robot_step函數執行的中間停止。 Webots API函數已執行，但僅在調用wb_robot_step函數時（即，控制器進程與Webots進程進行通信時），它們才被應用到仿真世界。 模擬停止時，已經計算出新的模擬狀態，更新了模擬時間，並且準備了新的傳感器值。 請注意，第一步也包括初始化。 因此，第二個wb_robot_step函數調用之前的所有語句都將執行。</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>Using Sensors and Actuators Together</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>一起使用傳感器和執行器</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>Webots and each robot controller are executed in separate processes. For example, if a simulation involves two robots, there will be three processes in total: one for Webots and two for the two robots. Each controller process exchanges sensors and actuators data with the Webots process during the <code>wb_robot_step</code><span><span> </span>function calls. So for example, the<span> </span></span><code>wb_motor_set_position</code><span><span> </span>function does not immediately send the data to Webots. Instead it stores the data locally and the data is effectively sent when the<span> </span></span><code>wb_robot_step</code><span><span> </span>function is called.</span></span></span></span></span></span></span></p>
<div class="tlid-results-container results-container">
<div class="tlid-result result-dict-wrapper">
<div class="result tlid-copy-target">
<div class="text-wrap tlid-copy-target">
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span title="">Webot和每個機器人控制器在單獨的過程中執行。</span><span> </span><span class="" title="">例如，如果一個模擬涉及兩個機器人，則總共將有三個過程：一個用於Webot，兩個用於兩個機器人。</span><span> </span><span class="" title="">在wb_robot_step函數調用期間，每個控制器進程都與Webots進程交換傳感器和執行器數據。</span><span> </span><span class="" title="">因此，例如，wb_motor_set_position函數不會立即將數據發送到Webots。</span><span> </span><span class="" title="">相反，它在本地存儲數據，並且在調用wb_robot_step函數時有效地發送了數據。</span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>For that reason the following code snippet is a bad example. Clearly, the value specified with the first call to the </span><code>wb_motor_set_position</code><span><span> </span>function will be overwritten by the second call:</span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>因此，以下代碼段是一個不好的示例。 顯然，第一次調用wb_motor_set_position函數指定的值將被第二次調用覆蓋：</span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><img alt="" height="134" src="https://s40723118.github.io/cd2020/images/8.jpg" width="900"/></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>Similarly this code does not make much sense either:</span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>同樣，此代碼也沒有太大意義：</span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><img alt="" height="215" src="https://s40723118.github.io/cd2020/images/9.jpg" width="690"/></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span>Since there was no call to the <code>wb_robot_step</code><span><span> </span>function between the two sensor readings, the values returned by the sensor cannot have changed in the meantime. A working version would look like this:</span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span>由於在兩個傳感器讀數之間沒有調用wb_robot_step函數，因此在此期間傳感器返回的值不能更改。 工作版本如下所示：</span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span><img alt="" height="281" src="https://s40723118.github.io/cd2020/images/10.jpg" width="638"/></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"><span class="" title=""><span><span></span></span></span></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0">
<p>However, the generally recommended approach is to have a single<span> </span><code>wb_robot_step</code><span> </span>function call in the main control loop, and to use it to update all the sensors and actuators simultaneously, like this:</p>
<pre>但是，通常建議的方法是在主控制循環中只有一個wb_robot_step函數調用，並使用它同時更新所有傳感器和執行器，如下所示：<br/><br/><img alt="" height="161" src="https://s40723118.github.io/cd2020/images/11.jpg" width="555"/></pre>
<p><span>Note that it is important to call the </span><code>wb_robot_step</code><span><span> </span>function at the beginning of the loop, in order to make sure that the sensors already have valid values prior to entering the<span> </span></span><code>readSensors</code><span><span> </span>function. Otherwise the sensors will have undefined values during the first iteration of the loop, hence, the following is not a good example:</span></p>
<p><span>請注意，在循環開始時調用wb_robot_step函數很重要，以確保在進入readSensors函數之前傳感器已經具有有效值。 否則，在循環的第一次迭代中，傳感器將具有不確定的值，因此，以下示例不是一個好例子：</span></p>
<p><span><img alt="" height="165" src="https://s40723118.github.io/cd2020/images/12.jpg" width="983"/></span></p>
<p><span>Here is a complete example of using sensors and actuators together. The robot used here is using differential steering. It uses two proximity sensors (<a href="https://cyberbotics.com/doc/reference/distancesensor">DistanceSensor</a><span>) to detect obstacles.</span></span></p>
<p><span><span>這是一起使用傳感器和執行器的完整示例。 這裡使用的機器人正在使用差速轉向。 它使用兩個接近傳感器（DistanceSensor）來檢測障礙物。</span></span></p>
<p><span><span><img alt="" height="755" src="https://s40723118.github.io/cd2020/images/13.jpg" width="703"/></span></span></p>
<p><span><span>Using Controller Arguments</span></span></p>
<p><span><span>使用控制器參數</span></span></p>
<p><span><span>In the ".wbt" file, it is possible to specify arguments that are passed to a controller when it starts. They are specified in the controllerArgs field of the Robot node, and they are passed as parameters of the main function. For example, this can be used to specify parameters that vary for each robot's controller.<br/>For example if we have:</span></span></p>
<p><span><span>在“ .wbt”文件中，可以指定啟動時傳遞給控制器的參數。 它們在Robot節點的controllerArgs字段中指定，並作為主函數的參數傳遞。 例如，可用於指定隨每個機器人控制器而變化的參數。<br/>例如，如果我們有：</span></span></p>
<p><span><span><img alt="" height="125" src="https://s40723118.github.io/cd2020/images/14.jpg" width="543"/></span></span></p>
<p><span><span>And if the controller's name is <em>"demo"</em><span>, then this sample controller code:</span></span></span></p>
<p><span><span><span>如果控制器的名稱為“ demo”，則此示例控制器代碼為：</span></span></span></p>
<p><span><span><span><img alt="" height="280" src="https://s40723118.github.io/cd2020/images/15.jpg" width="433"/></span></span></span></p>
<p><span><span><span>This will print:</span></span></span></p>
<p><span><span><span>這將打印：</span></span></span></p>
<p><span><span><span><img alt="" height="108" src="https://s40723118.github.io/cd2020/images/16.jpg" width="261"/></span></span></span></p>
<p><span><span><span>Controller Termination</span></span></span></p>
<p><span><span><span>控制器終端</span></span></span></p>
<p><span><span><span>Usually a controller process runs in an endless loop: it is terminated (killed) when Webots quits, the simulation is reset, the world is reloaded, a new simulation is loaded, or the controller name is changed in the Webots scene tree. The controller cannot prevent its own termination but it can be notified shortly before this happens. </span></span></span></p>
<p><span><span><span>通常，控制器進程會無休止地運行：當Webots退出，模擬被重置，世界被重新加載，新的模擬被加載或者Webots場景樹中的控制器名稱被更改時，它終止（被殺死）。 控制器無法阻止其自身終止，但是可以在發生這種情況之前立即通知控制器。</span></span></span></p>
<p><span><span><span>The <code>wb_robot_step</code><span><span> </span>function returns -1 when the controller process is going to be terminated by Webots. Then the controller has 1 second (real time) to save important data, close files, etc. before it is effectively killed by Webots. Here is an example that shows how to save data before the upcoming termination:</span></span></span></span></p>
<p><span><span><span><span>當控制器進程將由Webots終止時，wb_robot_step函數返回-1。 然後，控制器將有1秒（實時）的時間來保存重要數據，關閉文件等，直到Webots有效地將其殺死。 這是顯示如何在即將終止之前保存數據的示例：</span></span></span></span></p>
<p><span><span><span><span><img alt="" height="481" src="https://s40723118.github.io/cd2020/images/17.jpg" width="511"/></span></span></span></span></p>
<p><span><span><span><span>In some cases, it is up to the controller to make the decision of terminating the simulation. For example in the case of search and optimization algorithms: the search may terminate when a solution is found or after a fixed number of iterations (or generations).</span></span></span></span></p>
<p><span><span><span><span>在某些情況下，取決於控制器來決定終止仿真。 例如，在搜索和優化算法的情況下：當找到解決方案時或在固定數量的迭代（或生成）之後，搜索可能會終止。</span></span></span></span></p>
<p><span><span><span><span>In this case the controller should just save the experiment results and quit by returning from the <code>main</code><span><span> </span>function or by calling the<span> </span></span><code>exit</code><span><span> </span>function. This will terminate the controller process and freeze the simulation at the current simulation step. The physics simulation and every robot involved in the simulation will stop.</span></span></span></span></span></p>
<p><span><span><span><span><span>在這種情況下，控制器應只保存實驗結果並通過從主函數返回或調用退出函數退出。 這將終止控制器過程並凍結當前模擬步驟的模擬。 物理模擬以及模擬中涉及的每個機器人都將停止。</span></span></span></span></span></p>
<p><span><span><span><span><span><img alt="" height="121" src="https://s40723118.github.io/cd2020/images/18.jpg" width="341"/></span></span></span></span></span></p>
<p><span><span><span><span><span>If only one robot controller needs to terminate but the simulation should continue with the other robots, then the terminating robot should call the <code>wb_robot_cleanup</code><span><span> </span>function right before quitting:</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>如果僅一個機器人控制器需要終止，而仿真應與其他機器人繼續進行，則終止的機器人應在退出之前立即調用wb_robot_cleanup函數：</span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><img alt="" height="145" src="https://s40723118.github.io/cd2020/images/19.jpg" width="376"/></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span>Note that the exit status as well as the value returned by the <code>main</code><span><span> </span>function are ignored by Webots.</span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span>請注意，Webots會忽略退出狀態以及主函數返回的值。</span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span>Shared Libraries</span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span>共享庫</span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span>Creating shared libraries can be very useful to share code between controllers and/or plugins. There are several ways to do so, but we recommend to place them into a subdirectory of the <code>libraries</code><span><span> </span>directory of your project. Indeed the environment variables of the controllers are modified to include these paths into your [[DY]LD_LIBRARY_]PATH environment variable (depending on the OS). Moreover the main Makefile ("</span><a href="https://github.com/cyberbotics/webots/tree/master/resources/Makefile.include" target="_blank">WEBOTS_HOME/resources/Makefile.include</a><span>") used to compile Webots controllers is able to create shared libraries and to link easily with the Controller libraries, ODE or the Qt framework.</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>創建共享庫對於在控制器和/或插件之間共享代碼非常有用。 有幾種方法可以這樣做，但是我們建議將它們放在項目庫目錄的子目錄中。 實際上，已修改控制器的環境變量，以將這些路徑包括到您的[[DY] LD_LIBRARY_] PATH環境變量中（取決於OS）。 此外，用於編譯Webots控制器的主要Makefile（“ WEBOTS_HOME / resources / Makefile.include”）能夠創建共享庫，並可以輕鬆地與Controller庫，ODE或Qt框架鏈接。</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>A good example of this is the Qt utility library located there: "WEBOTS_HOME/resources/projects/libraries/qt_utils".<br/>If for some reason shared libraries cannot be in the libraries directory, the WEBOTS_LIBRARY_PATH environment variable will be very helpful. The paths it contains will be added at the beginning of the library search path([[DY]LD_LIBRARY_]PATH) when starting the controller.</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>一個很好的例子是位於此處的Qt實用程序庫：“ WEBOTS_HOME / resources / projects / libraries / qt_utils”。<br/>如果由於某種原因共享庫不能位於庫目錄中，則WEBOTS_LIBRARY_PATH環境變量將非常有幫助。 啟動控制器時，它包含的路徑將添加到庫搜索路徑（[[DY] LD_LIBRARY_] PATH）的開頭。</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>Environment Variables</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>環境變量</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>For some projects it will be necessary to define or change variables defined in your environment. They can be changed in the settings of the computer but it may last only for the current session or create conflict with other applications or projects. Webots offers an elegant solution to this. A configuration file named "runtime.ini" can be added to the controller directory. Any environment variable defined in this file will be loaded to the environment each time the controller starts.</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>對於某些項目，有必要定義或更改在您的環境中定義的變量。 可以在計算機的設置中更改它們，但可能僅持續當前會話，或者與其他應用程序或項目產生衝突。 Webots為此提供了一個優雅的解決方案。 可以將名為“ runtime.ini”的配置文件添加到控制器目錄。 每次控制器啟動時，此文件中定義的任何環境變量都會加載到環境中。</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>This configuration file uses the standard INI template that is really simple and easy to write and read. It contains pairs of key and value that can be inside [sections]. Comments can be written on a line after using a semicolon ';' character.<br/>Environment variables in this file can contain references to other environment variables using this syntax : $(MY_VARIABLE_NAME). They will be automatically replaced by the actual value already existing in the environment. The Webots "runtime.ini" supports 7 sections:</span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span>此配置文件使用標準的INI模板，該模板非常簡單，易於讀寫。 它包含可以在[sections]內部的鍵和值對。 使用分號“;”後可以在一行上寫註釋。 字符。<br/>該文件中的環境變量可以使用以下語法包含對其他環境變量的引用：$（MY_VARIABLE_NAME）。 它們將自動替換為環境中已經存在的實際值。 Webots的“ runtime.ini”支持7個部分：</span></span></span></span></span></span></span></span></p>
<ul>
<li>
<p><code>[environment variables with paths]</code></p>
<p>This section should only contain environment variables with either relative or absolute paths. Paths must be separated using the colon symbol ':' and directory components must be separated using the slash symbol '/'. Variables declared in this section will be added on every platform. On Windows, colons will be replaced by semicolon and slash will be replaced by backslash according to the Windows syntax.</p>
</li>
<li>
<p><code>[environment variables]</code></p>
<p>Environment variables defined in this section will also be added to the environment on every platform but they will be written directly with no syntax change. It's a good location for variables that don't contain any path.</p>
</li>
<li>
<p><code>[environment variables for Windows]</code></p>
<p>Variables defined in this section will only be added to the environment if the controller is ran on the Windows platform. If you want to declare paths in this section, the value should be written between double-quotes symbols ".</p>
</li>
<li>
<p><code>[environment variables for macOS]</code></p>
<p>Variables defined here will only be added on macOS and ignored on other platforms.</p>
</li>
<li>
<p><code>[environment variables for Linux]</code></p>
<p>Variables defined here will be added on all Linux platforms but not on Mac nor Windows.</p>
</li>
<li>
<p><code>[environment variables for Linux 32]</code></p>
<p>These variables will be added only if the Linux platform is 32 bit.</p>
</li>
<li>
<p><code>[environment variables for Linux 64]</code></p>
<p>These variables will be added only if the Linux platform is 64 bit.</p>
</li>
</ul>
<p>[帶路徑的環境變量]</p>
<p>此部分應僅包含具有相對路徑或絕對路徑的環境變量。路徑必須使用冒號'：'分隔，目錄組件必須使用斜杠'/'分隔。本節中聲明的變量將在每個平台上添加。在Windows上，根據Windows語法，冒號將由分號替換，斜杠將由反斜杠替換。</p>
<p>[環境變量]</p>
<p>本節中定義的環境變量也將添加到每個平台的環境中，但是它們將直接編寫而無需更改語法。對於不包含任何路徑的變量，這是一個很好的位置。</p>
<p>[Windows環境變量]</p>
<p>僅當在Windows平台上運行控制器時，才會將本節中定義的變量添加到環境中。如果要在本節中聲明路徑，則應在雙引號符號“之間寫入值。</p>
<p>[macOS的環境變量]</p>
<p>此處定義的變量將僅在macOS上添加，而在其他平台上被忽略。</p>
<p>[Linux的環境變量]</p>
<p>此處定義的變量將在所有Linux平台上添加，但不會在Mac和Windows上添加。</p>
<p>[Linux 32的環境變量]</p>
<p>僅當Linux平台為32位時，才添加這些變量。</p>
<p>[Linux 64的環境變量]</p>
<p>僅當Linux平台是64位時，才添加這些變量。</p>
<p><span>Here is an example of a typical runtime.ini file.</span></p>
<p><span>這是典型的runtime.ini文件的示例。</span></p>
<p><span><img alt="" height="321" src="https://s40723118.github.io/cd2020/images/20.jpg" width="553"/></span></p>
<p><span>Languages Settings</span></p>
<p>語言設定</p>
<p><span>The "runtime.ini" file may also contain language specific sections, named </span><code>[java]</code><span>,<span> </span></span><code>[python]</code><span><span> </span>and<span> </span></span><code>[matlab]</code><span>. Each of this section may include two keys, namely<span> </span></span><code>COMMAND</code><span><span> </span>and<span> </span></span><code>OPTIONS</code><span>. The<span> </span></span><code>COMMAND</code><span><span> </span>key allows you to define a specific version of the language interpreter whereas the<span> </span></span><code>OPTIONS</code><span><span> </span>key allows you to access specific options that will be passed immediately to the language interpreter. For example:</span></p>
<p><span>“ runtime.ini”文件還可能包含特定於語言的部分，名為[java]，[python]和[matlab]。 每個部分都可以包括兩個鍵，即COMMAND和OPTIONS。 COMMAND鍵允許您定義語言解釋器的特定版本，而OPTIONS鍵則允許您訪問將立即傳遞給語言解釋器的特定選項。 例如：</span></p>
<p><span><img alt="" height="124" src="https://s40723118.github.io/cd2020/images/21.jpg" width="413"/></span></p>
<p><span>In the example above, the resulting command issued by Webots will be: <code>/opt/local/bin/python2.7 -m package.name.given my_controller.py</code><span><span> </span>possibly followed by the value of the<span> </span></span><code>controllerArgs</code><span><span> </span>field of the corresponding<span> </span></span><a href="https://cyberbotics.com/doc/reference/robot">Robot</a><span><span> </span>node.</span></span></p>
<p><span><span>在上面的示例中，Webots發出的結果命令將是：/opt/local/bin/python2.7 -m package.name.given my_controller.py，其後可能是相應Robot節點的controllerArgs字段的值。</span></span></p>
<p><span><span><img alt="" height="196" src="https://s40723118.github.io/cd2020/images/22.jpg" width="419"/></span></span></p>
<p><span><span><img alt="" height="123" src="https://s40723118.github.io/cd2020/images/23.jpg" width="703"/></span></span></p>
<p><span><span></span></span></p>
<div class="tlid-input input">
<div class="source-wrap">
<div class="input-full-height-wrapper tlid-input-full-height-wrapper">
<div class="source-input">
<div class="source-footer-wrap source-or-target-footer">
<div class="source-footer">
<div class="speech-wrap source-or-target-footer-button left-positioned">
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" id="gt-speech" role="button" tabindex="0"><em><strong><span class="jfk-button-img">Python Example</span></strong></em></div>
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" role="button" tabindex="0"><em><strong><span class="jfk-button-img">Python範例</span></strong></em></div>
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" role="button" tabindex="0"><em><strong><span class="jfk-button-img"></span></strong></em></div>
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" role="button" tabindex="0"><em><strong><span class="jfk-button-img"><img alt="" height="664" src="https://s40723118.github.io/cd2020/images/24.jpg" width="1055"/></span></strong></em></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<h3>感測器</h3>
<h4>相機傳感器</h4>
<p>對於大多數應用程序而言，添加通用的Camera節點就足夠了。 通用相機是可自定義的（分辨率，視野，噪點等），默認情況下包括變焦和聚焦機制。 提供特殊效果，例如運動模糊，各種噪聲模型，鏡頭畸變和使用球形投影。除了添加通用的Camera節點外，Webot中還提供了一些預定義的Camera模型。</p>
<p><strong>智能相機</strong></p>
<p>如果將“識別”節點添加到相機，則相機不僅可以返回圖像，而且還可以返回相機圖像中檢測到的所有對象及其大小和位置。 因此，模擬像是Mobileye之類的智能相機非常容易。</p>
<p><img alt="smart_camera.png" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/sensors/smart_camera.png"/></p>
<p><strong>MultiSense S21</strong></p>
<p>MultiSense S21是基於立體相機的距離傳感器。我們的傳感器模型包括多個Webots設備。內部的IntertialUnit設備用於獲取設備的側傾角，俯仰角和偏航角。 可以使用Webots相機獨立檢索立體相機的左右RGB圖像。 或者，可以在MultiSense S21設備的中央啟用RGB相機和RangeFinder設備。 存在這兩個“元”設備以模仿由真實設備生成的3D彩色點的雲。</p>
<p>可以使用下表從MultiSenseS21.name字段計算用於從控制器檢索設備的內部設備名稱：</p>
<p><img alt="" height="529" src="https://s40723123.github.io/cd2020/images/1586269302004.jpg" width="398"/></p>
<p><img alt="multisense_s21.png" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/sensors/multisense_s21.thumbnail.png"/></p>
<p><img alt="" height="365" src="https://s40723123.github.io/cd2020/images/1586269413764.jpg" width="477"/></p>
<p>名稱字段定義MultiSenseS21名稱，並用於計算內部設備名稱（請參閱此表）。</p>
<p>cameraWidth和cameraHeight字段指定所有內部渲染設備（即Cameras和RangeFinder）的分辨率。</p>
<p>cameraFieldOfView字段指定所有內部渲染設備的水平視場。</p>
<p>cameraNoise字段指定所有內部渲染設備的噪聲（請參閱Camera.noise）。</p>
<p>rangeFinderNoise字段指定內部元RangeFinder的噪聲（請參閱RangeFinder.noise）。</p>
<p>rangeFinderMaxRange字段指定內部元RangeFinder的最大範圍（請參閱RangeFinder.maxRange）。</p>
<p>leftCamera，rightCamera，metaCamera和metaRangeFinder字段允許啟用相應的內部渲染設備。</p>
<p>enablePhysics字段指定傳感器是否應該受到物理影響（質量= 1.5 [kg]）。</p>
<h4>距離傳感器</h4>
<p>對於大多數應用程序而言，添加通用的DistanceSensor節點就足夠了，因為它們是可自定義的（分辨率，lookupTable，光圈等）。此外，Webot中提供了一些預定義的商業化模型，例如某些紅外傳感器。</p>
<p><strong>Sharp GP2D120</strong></p>
<p><img alt="sharp_GP2D120.png" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/sensors/sharp_GP2D120.png"/></p>
<p>Sharp GP2D120是一款具有集成信號處理和模擬電壓輸出的測距傳感器。 該設備輸出與檢測距離相對應的電壓。該型號具有以下規格：</p>
<p>有效範圍：<span>4 to 30 [cm]</span></p>
<p>輸出類型：類比</p>
<p>響應時間：39 [ms]</p>
<p>啟動延遲：44 [ms]</p>
<p>平均消耗：33 [mA]</p>
<p>原型SharpGP2D120 {<br/>   SFVec3f轉換0 0 0<br/>   旋轉旋轉0 1 0 0<br/>   SFString名稱“夏普的紅外傳感器GP2D120”<br/>   SFString模型“ GP2D120”</p>
<p>根據數據表中的特徵，DistanceSensor的lookupTable字段已經實現。</p>
<p>wb_distance_sensor_get_value函數返回測量的電壓/強度。 要轉換這些值，請使用以下公式：</p>
<ul>
<li>Convert meters to voltage:<span> </span><code>y(x) = 0.5131*x^(-0.5735)-0.6143</code></li>
<li>Convert voltage to meters:<span> </span><code>y(x) = 0.1594*x^(-0.8533)-0.02916</code></li>
</ul>
<p><strong>Sharp GP2Y0A02YK0F</strong></p>
<p><strong><img alt="sharp_GP2Y0A02YK0F.png" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/sensors/sharp_GP2Y0A02YK0F.png"/></strong></p>
<p>Sharp GP2Y0A02YK0F是一種測距傳感器單元，由PSD（位置敏感檢測器），IR-LED（紅外發光二極管）和信號處理電路的集成組合組成。 由於採用三角測量法，物體的反射率，環境溫度和工作持續時間的變化不容易影響距離檢測。 該設備輸出與檢測距離相對應的電壓。 因此，該傳感器也可以用作接近傳感器。</p>
<p>該型號具有以下規格：</p>
<p>有效範圍：20至150 [cm]</p>
<p>輸出類型：類比</p>
<p>響應時間：33 [ms]</p>
<p>啟動延遲：50 [ms]</p>
<p>平均消耗：33 [mA]</p>
<p>原型SharpGP2Y0A02YK0F {<br/>   SFVec3f轉換0 0 0<br/>   旋轉旋轉0 1 0 0<br/>   SFString名稱“夏普的紅外傳感器GP2Y0A02YK0F”</p>
<p>根據數據表中的特徵，DistanceSensor的lookupTable字段已經實現。wb_distance_sensor_get_value函數返回測量的電壓/強度。 要轉換這些值，請使用以下公式：</p>
<ul>
<li>Convert meters to voltage:<span> </span><code>y(x) = 1.784*x^(-0.4215)-1.11</code></li>
<li>Convert voltage to meters:<span> </span><code>y(x) = 0.7611*x^(-0.9313)-0.1252</code></li>
</ul>
<p><strong>Sharp GP2Y0A41SK0F</strong></p>
<p><strong><img alt="sharp_GP2Y0A41SK0F.png" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/sensors/sharp_GP2Y0A41SK0F.png"/></strong></p>
<p>Sharp GP2Y0A41SK0F是一種測距傳感器單元，由PSD（位置敏感檢測器），IR-LED（紅外發光二極管）和信號處理電路的集成組合組成。 由於採用三角測量法，物體的反射率，環境溫度和工作持續時間的變化不容易影響距離檢測。 該設備輸出與檢測距離相對應的電壓。 因此，該傳感器也可以用作接近傳感器。</p>
<p>該型號具有以下規格：</p>
<p>有效範圍：4到30 [cm]<br/>輸出類型：類比<br/>響應時間：16.5 [ms]<br/>啟動延遲：26 [ms]<br/>平均消耗：12 [mA]</p>
<p><span>原型SharpGP2Y0A41SK0F {<br/>   SFVec3f轉換0 0 0<br/>   旋轉旋轉0 1 0 0<br/>   SFString名稱“夏普的紅外傳感器GP2Y0A41SK0F”<br/></span></p>
<p>根據數據表中的特徵，DistanceSensor的lookupTable字段已經實現。wb_distance_sensor_get_value函數返回測量的電壓/強度。 要轉換這些值，請使用以下公式：</p>
<ul>
<li>Convert meters to voltage:<span> </span><code>y(x) = 0.5131*x^(-0.5735)-0.6143</code></li>
<li>Convert voltage to meters:<span> </span><code>y(x) = 0.1594*x^(-0.8533)-0.02916</code><code></code></li>
</ul>
<p><strong>Sharp GP2Y0A710K0F</strong></p>
<p><strong><img alt="sharp_GP2Y0A710K0F.png" src="https://raw.githubusercontent.com/cyberbotics/webots/master/docs/guide/images/sensors/sharp_GP2Y0A710K0F.thumbnail.png"/></strong></p>
<p>Sharp GP2Y0A710K0F是一種測距傳感器單元，由PSD（位置敏感檢測器），IR-LED（紅外發光二極管）和信號處理電路的集成組合組成。 由於採用三角測量法，物體的反射率，環境溫度和工作持續時間的變化不容易影響距離檢測。 該設備輸出與檢測距離相對應的電壓。 因此，該傳感器也可以用作接近傳感器。</p>
<p>該型號具有以下規格：</p>
<p>有效範圍：100至550 [cm]<br/>輸出類型：類比<br/>響應時間：21 [ms]<br/>啟動延遲：26 [ms]<br/>平均消耗：30 [mA]</p>
<p>原型SharpGP2Y0A710K0F {<br/>   SFVec3f轉換0 0 0<br/>   旋轉旋轉0 1 0 0<br/>   SFString名稱“夏普的紅外傳感器GP2Y0A710K0F”</p>
<p>根據數據表中的特徵，DistanceSensor的lookupTable字段已經實現。wb_distance_sensor_get_value函數返回測量的電壓/強度。 要轉換這些值，請使用以下公式：</p>
<ul>
<li>Convert meters to voltage:<span> </span><code>y(x) = 1.962*x^(-0.5214)+0.4926</code></li>
<li>Convert voltage to meters:<span> </span><code>y(x) = 20.24*x^(-4.76)+0.6632</code><code></code></li>
</ul>
<h3>執行器(線性馬達,發光二極管,肌肉,鋼筆)</h3>
<p>線性馬達</p>
<p>衍生自<a href="https://cyberbotics.com/doc/reference/motor">Motor</a>。</p>
<p>LinearMotor {</p>
<p>  SFString name     "linear motor"              # any string</p>
<p>  SFFloat  maxForce 10                          # [0, inf)</p>
<p>  SFString sound    "sounds/linear_motor.wav"   # any string</p>
<p>描述</p>
<p>甲<a href="https://cyberbotics.com/doc/reference/linearmotor#linearmotor"><span>直線電機</span></a>節點可以用來驅動一個<a href="https://cyberbotics.com/doc/reference/sliderjoint">SliderJoint</a>和一個<a href="https://cyberbotics.com/doc/reference/track"><span>軌道</span></a>。</p>
<p>領域摘要</p>
<ul>
<li>該name字段指定電機設備的名稱標識符。該wb_robot_get_device函數所引用的名稱。默認為"linear motor"。</li>
<li>該maxForce字段同時指定了電動機<em>可用力的</em>上限和默認值。該<em>可力</em>是可用於執行所請求的動作電動機的動力。它以<em>牛頓</em>[N] 表示。該wb_motor_set_available_force功能可用於在運行時更改<em>可用力</em>。的值maxForce應始終為零或正（默認值為10 N）。較小的maxForce值可能導致電動機由於其重量或其他外力而無法移動到目標位置。  </li>
</ul>
<p><em><strong>發光二極管</strong></em></p>
<p>源自<a href="https://cyberbotics.com/doc/reference/device"><span>設備</span></a>和<a href="https://cyberbotics.com/doc/reference/solid"><span>實體</span></a>。</p>
<p>LED {  MFColor color   [ 1 0 0 ]   # any color  SFBool  gradual FALSE       # {TRUE, FALSE}}</p>
<p><em><strong>描述</strong></em></p>
<p>所述<a href="https://cyberbotics.com/doc/reference/led#led">LED</a>節點用於發光二極管（LED）進行建模。LED產生的光可用於調試或提供信息。結果顏色僅應用於<a href="https://cyberbotics.com/doc/reference/led#led">LED</a>節點的第一個子節點。如果第一個子對<a href="https://cyberbotics.com/doc/reference/pbrappearance"><span>像是</span>“ </a><a href="https://cyberbotics.com/doc/reference/shape"><span>形狀</span>”</a>節點，則emissiveColor其“ <a href="https://cyberbotics.com/doc/reference/material"><span>材料</span>”</a>或“ <a href="https://cyberbotics.com/doc/reference/pbrappearance">PBRAppearance”</a>節點的字段會更改。如果第一個孩子是<a href="https://cyberbotics.com/doc/reference/light">Light</a>節點，則其color字段會更改。否則，如果第一個孩子是“ <a href="https://cyberbotics.com/doc/reference/group"><span>組</span>”</a>節點，則對該節點執行遞歸搜索，以查找必須修改的顏色字段，因此每個“ <a href="https://cyberbotics.com/doc/reference/light"><span>光</span>”</a>，“ <a href="https://cyberbotics.com/doc/reference/shape"><span>形狀</span>”</a>和“ <a href="https://cyberbotics.com/doc/reference/group"><span>組</span>”</a>節點根據以前的規則進行了更改。就<a href="https://cyberbotics.com/doc/reference/light">Light</a>節點而言，<a href="https://cyberbotics.com/doc/reference/led#led">LED</a>節點只能接受<a href="https://cyberbotics.com/doc/reference/pointlight">PointLight</a>和<a href="https://cyberbotics.com/doc/reference/spotlight">SpotLight</a>節點作為子節點。</p>
<p>請注意，將由<a href="https://cyberbotics.com/doc/reference/led#led">LED</a>功能自動更改的<a href="https://cyberbotics.com/doc/reference/material">Material</a>和<a href="https://cyberbotics.com/doc/reference/light">Light</a>節點不能是<a href="https://cyberbotics.com/doc/reference/def-and-use">USE</a>節點。</p>
<p><em><strong>領域摘要</strong></em></p>
<ul>
<li>color：這定義了LED設備的顏色。熄滅時，LED始終為黑色。但是，當打開時，它可能具有LED編程接口指定的不同顏色。默認情況下，該color定義僅定義一種顏色（紅色），但是您可以更改此顏色並添加可以從LED編程界面中選擇的其他顏色。但是，定義的顏色數量取決於gradual字段的值（請參見下文）。</li>
<li>gradual：這定義了LED的類型。如果設置為FALSE，則LED可以採用color列表中定義的任何顏色值。如果設置為TRUE，則color列表應該為空或僅包含一種顏色值。如果color列表為空，則該LED為RGB LED，並且可以採用R8G8B8顏色空間中的任何顏色（1600萬種可能性）。如果color列表包含單一顏色，則LED為單色，並且其強度可以在0（關閉）和255（最大強度）之間進行調整。</li>
</ul>
<p><strong>LED功能</strong></p>
<p><strong>wb_led_set</strong></p>
<p><strong>wb_led_get</strong></p>
<p>CC ++蟒蛇爪哇的MATLABROS</p>
<p><span><span><span>#</span><span><span><strong><span>include</span></strong></span></span></span><span><span> </span><span><span><span>&lt;webots/led.h&gt;</span></span></span></span></span> <span><span><strong><span><span><span>void</span></span></span></strong></span></span><span><span> </span><strong><span><span><span>wb_led_set</span></span></span></strong></span><span><span><span><span>(WbDeviceTag tag,<span> </span></span></span></span><span><span><span><strong><span><span>int</span></span></strong></span></span></span><span><span><span><span> </span>value)</span></span></span></span>;<span><span><strong><span><span><span>int</span></span></span></strong></span></span><span><span> </span><strong><span><span><span>wb_led_get</span></span></span></strong></span><span><span><span><span>(WbDeviceTag tag)</span></span></span></span>;</p>
<p><strong>描述</strong></p>
<p><em>打開或關閉</em><em>LED</em><em>並讀取其狀態</em></p>
<p>該wb_led_set功能可打開或關閉LED，可能會改變其顏色。如果value參數為0，則LED熄滅。否則，將其打開。</p>
<p>對於非漸變LED（gradual字段設置為FALSE），如果value參數為1，則使用color相應<a href="https://cyberbotics.com/doc/reference/led#led">LED</a>節點的字段中指定的第一種顏色打開<a href="https://cyberbotics.com/doc/reference/led#led">LED</a>。如果value參數為2，則使用color在<a href="https://cyberbotics.com/doc/reference/led#led">LED</a>節點的字段中指定的第二種顏色打開<a href="https://cyberbotics.com/doc/reference/led#led">LED</a>，依此類推。該value參數不應大於color相應<a href="https://cyberbotics.com/doc/reference/led#led">LED</a>節點的字段的大小。</p>
<p>對於單色LED（gradual字段設置為TRUE並且color字段僅包含一種顏色），該value參數指示LED的強度在0（關閉）到255（最大強度）的範圍內。</p>
<p>對於RGB LED（gradual字段設置為TRUE並且color字段包含空列表），該value參數指示LED的RGB顏色，範圍為0（關閉或黑色）至0xffffff（白色）。格式為R8G8B8：最高8位（左側）指示紅色電平（介於0x00和0xff之間）。位8至15指示綠色電平，而最低有效8位（右側）指示藍色電平。例如，0xff0000是紅色，0x00ff00是綠色，0x0000ff是藍色，0xffff00是黃色，依此類推。</p>
<p>該wb_led_get函數返回作為最後一個wb_led_set函數調用的參數給出的值。</p>
<p>   </p>
<p><em><strong>肌肉</strong></em></p>
<p>Muscle {  SFDouble volume      0.01    # [0, inf)  SFVec3f  startOffset 0 0 0   # any vector  SFVec3f  endOffset   0 0 0   # any vector  MFColor  color       [ ]     # any color  SFBool   castShadows TRUE    # {TRUE, FALSE}  SFBool   visible     TRUE    # {TRUE, FALSE}}</p>
<p><em><strong>描述</strong></em></p>
<p>甲<a href="https://cyberbotics.com/doc/reference/muscle#muscle"><span>肌肉</span></a>節點可用於以圖形方式顯示的人工肌肉的收縮實現使<a href="https://cyberbotics.com/doc/reference/joint"><span>關節</span></a>和<a href="https://cyberbotics.com/doc/reference/motor"><span>電機</span></a>節點。使用球體表示人造肌肉，其中對稱軸是關節最近的上<a href="https://cyberbotics.com/doc/reference/transform"><span>變換</span></a>節點和endPoint <a href="https://cyberbotics.com/doc/reference/solid"><span>實體</span></a>節點之間的向量。其他兩個軸具有基於對稱軸長度計算的相同長度，以便在拉伸過程中體積保持恆定。</p>
<p>請注意，如果<a href="https://cyberbotics.com/doc/reference/track">Track</a>節點中包含<a href="https://cyberbotics.com/doc/reference/motor">Motor</a>設備，則無法使用<a href="https://cyberbotics.com/doc/reference/muscle#muscle">Muscle</a>節點。</p>
<p><em><strong>領域摘要</strong></em></p>
<ul>
<li>該volume字段指定圖形橢球體的恆定體積。當關節移動時，該值用於重新計算肌肉的形狀。</li>
<li>的startOffset肌肉的底部點的位置的最近的坐標系中指定球狀體上<a href="https://cyberbotics.com/doc/reference/transform"><span>變換</span></a>節點。如果startOffset是[0, 0, 0]，則橢球底點對應於最接近的上<a href="https://cyberbotics.com/doc/reference/transform"><span>變換</span></a>原點。</li>
<li>所述endOffset指定肌肉的頂點的位置的坐標系中球狀體<a href="https://cyberbotics.com/doc/reference/joint"><span>聯合</span></a>。endPoint<a href="https://cyberbotics.com/doc/reference/solid"><span>實體</span></a>節點。如果endOffset是[0, 0, 0]，則橢球體的最高點對應於endPoint <a href="https://cyberbotics.com/doc/reference/solid">Solid</a>原點。</li>
<li>該color字段指定三種不同肌肉狀態下球體的顏色：空閒（項目0），收縮（項目1）和放鬆（項目2）。顯示的顏色是通過將閒置顏色和當前狀態顏色與百分比（取決於電動機施加的力）混合而成的：</li>
</ul>
<p>o    color = idle_color * (1 - percentage) + other_color * percentage</p>
<p>在哪裡other_color收縮或放鬆色彩。僅使用三種顏色，因此，如果指定了更多項目，則將忽略它們。如果僅定義了兩種顏色，則當肌肉收縮或鬆弛時，將使用相同的顏色（項目1）。如果僅定義一種顏色，則將指定的顏色用於所有肌肉狀態。如果color字段為空，則所有肌肉狀態均使用默認顏色（純紅色）。</p>
<ul>
<li>該castShadows字段使用戶可以打開（TRUE）或關閉（FALSE）由肌肉球體網格投射的陰影。</li>
<li>該visible字段用於顯示（TRUE）或隱藏（FALSE）3D場景中的肌肉。</li>
</ul>
<p>  </p>
<p><em><strong>鋼筆</strong></em></p>
<p>源自<a href="https://cyberbotics.com/doc/reference/device"><span>設備</span></a>和<a href="https://cyberbotics.com/doc/reference/solid"><span>實體</span></a>。</p>
<p>Pen {  SFColor inkColor    0 0 0   # any color  SFFloat inkDensity  0.5     # [0, 1]  SFFloat leadSize    0.002   # [0, inf)  SFFloat maxDistance 0.0     # [0, inf)  SFBool  write       TRUE    # {TRUE, FALSE}}</p>
<p><em><strong>指數</strong></em></p>
<ul>
<li><a href="https://cyberbotics.com/doc/reference/pen#description"><span>描述</span></a></li>
<li><a href="https://cyberbotics.com/doc/reference/pen#field-summary"><span>領域摘要</span></a></li>
<li><a href="https://cyberbotics.com/doc/reference/pen#pen-functions"><span>筆功能</span></a>
<ul>
<li><a href="https://cyberbotics.com/doc/reference/pen#wb_pen_write">wb_pen_write</a></li>
<li><a href="https://cyberbotics.com/doc/reference/pen#wb_pen_set_ink_color">wb_pen_set_ink_color</a></li>
</ul>
</li>
</ul>
<p><em><strong>描述</strong></em></p>
<p><a href="https://cyberbotics.com/doc/reference/pen#pen">Pen</a>節點對連接到移動機器人的<a href="https://cyberbotics.com/doc/reference/pen#pen"><span>筆進行</span></a>建模，該筆通常用於顯示機器人的軌跡。<a href="https://cyberbotics.com/doc/reference/solid">Pen</a>設備的繪製方向與節點的<em>-y-</em>軸重合。因此，可以通過修改<a href="https://cyberbotics.com/doc/reference/solid"><span>實體</span></a>節點的旋轉和平移字段來對其進行調整。通過設置該maxDistance字段，可以定義<a href="https://cyberbotics.com/doc/reference/pen#pen"><span>筆</span></a>的範圍並僅在靠近設備的物體上繪畫。例如，使用較小的值maxDistance可以模擬僅在物理接觸時書寫的筆或鉛筆的真實行為。如果maxDistance設置為0（默認值），則範圍將不受限制。</p>
<p>為了可繪製，對象應該由一個<a href="https://cyberbotics.com/doc/reference/solid"><span>實體</span></a>節點組成，該<a href="https://cyberbotics.com/doc/reference/solid"><span>實體</span></a>節點包含一個帶有有效值的<a href="https://cyberbotics.com/doc/reference/shape">Shape</a>Geometry和一個<a href="https://cyberbotics.com/doc/reference/imagetexture">ImageTexture</a>。將已塗漆的圖層應用到紋理上，而無需對其進行修改。</p>
<p>繪製動作的精度主要取決於節點的subdivision場Geometry。較高的subdivision值會增加用於表示幾何圖形的多邊形的數量，因此可以進行更精確的紋理映射，但是也會降低場景的渲染速度。另一方面，如果紋理貼圖較差，則塗漆區域可能會顯示在與預期位置不同的位置。對於<a href="https://cyberbotics.com/doc/reference/indexedfaceset">IndexedFaceSet</a>，可以通過定義紋理映射並設置texCoord和texCoordIndex字段來提高精度。實際上，如果沒有給出紋理映射或給出無效的紋理映射，則係統將使用默認的常規映射。</p>
<p>“ pen.wbt”示例環境（位於Webots的“ projects / samples / devices / worlds”目錄中）提供了與配備筆的機器人一起使用的帶紋理的地板的示例。</p>
<p><strong>注意</strong>：<a href="https://cyberbotics.com/doc/reference/worldinfo">WorldInfo</a>節點的inkEvaporation字段控制墨水蒸發的速度（消失）。</p>
<p><strong>注意</strong>：可以通過紅外距離傳感器看到用鋼筆繪製的圖形。因此，可以實現機器人實驗，其中機器人用筆在地板上畫線，第二機器人用第一機器人畫的線進行跟隨行為。</p>
<p><em><strong>領域摘要</strong></em></p>
<ul>
<li>inkColor：定義筆墨水的顏色。可以使用此wb_pen_set_ink_color功能從pen API更改此字段。</li>
<li>inkDensity：定義墨水顏色的密度。該值應在[0,1]範圍內。也可以使用wb_pen_set_ink_color函數從pen API更改此字段。</li>
<li>leadSize：定義筆的“筆尖”的寬度。這允許機器人編寫更寬或更窄的軌道。</li>
<li>maxDistance：定義<a href="https://cyberbotics.com/doc/reference/pen#pen">Pen</a>設備與可繪畫對象之間的最大距離，並允許模擬接觸式書寫行為。小於或等於0的值表示無限的繪畫範圍。</li>
<li>write：此佈爾值字段允許機器人啟用或禁用用筆書寫。也可以使用wb_pen_write功能從pen API進行切換。</li>
</ul>
<p></p>
<p><em><strong>筆功能</strong></em></p>
<p><strong>wb_pen_write</strong></p>
<p>CC ++蟒蛇爪哇的MATLABROS</p>
<p><span><span><span>#</span><span><span><strong><span>include</span></strong></span></span></span><span><span> </span><span><span><span>&lt;webots/pen.h&gt;</span></span></span></span></span> <span><span><strong><span><span><span>void</span></span></span></strong></span></span><span><span> </span><strong><span><span><span>wb_pen_write</span></span></span></strong></span><span><span><span><span>(WbDeviceTag tag,<span> </span></span></span></span><span><span><span><strong><span><span>bool</span></span></strong></span></span></span><span><span><span><span> </span>write)</span></span></span></span>;</p>
<p><em><strong>描述</strong></em></p>
<p><em>啟用或禁用筆書寫</em></p>
<p>該wb_pen_write功能允許用戶打開或關閉筆設備以禁用或啟用書寫。如果該write參數為<em>true</em>，則指定的tag設備將寫入；否則為0。如果write為<em>false</em>，則不會。</p>
<p><strong>wb_pen_set_ink_color</strong></p>
<p>CC ++蟒蛇爪哇的MATLABROS</p>
<p><span><span><span>#</span><span><span><strong><span>include</span></strong></span></span></span><span><span> </span><span><span><span>&lt;webots/pen.h&gt;</span></span></span></span></span> <span><span><strong><span><span><span>void</span></span></span></strong></span></span><span><span> </span><strong><span><span><span>wb_pen_set_ink_color</span></span></span></strong></span><span><span><span><span>(WbDeviceTag tag,<span> </span></span></span></span><span><span><span><strong><span><span>int</span></span></strong></span></span></span><span><span><span><span> </span>color,<span> </span></span></span></span><span><span><span><strong><span><span>double</span></span></strong></span></span></span><span><span><span><span> </span>density)</span></span></span></span>;</p>
<p><em><strong>描述</strong></em></p>
<p><em>改變筆墨水的顏色</em></p>
<p>該wb_pen_set_ink_color功能更改指定tag設備的當前墨水顏色。的color是32位整數值，其限定在為0xRRGGBB十六進制格式（即油墨的新的顏色，0x000000處為黑色，0xFF0000為紅色，0x00FF00為綠色，0x0000FF是藍色的，0xFFA500是橙色，0x808080是灰色0XFFFFFF是白色的，等等。）。該density參數定義墨水密度，0表示透明墨水，1表示完全不透明的墨水。</p>
<p><em><strong>例</strong></em></p>
<p>wb_pen_set_ink_color(pen,<span>0xF01010</span>,<span>0.9</span>);</p>
<p>上面的陳述會將指示筆的墨水顏色更改為某种红色。</p>
<p><strong>注意</strong> [MATLAB]：在wb_pen_set_ink_color函數的MATLAB版本中，color參數必須是包含三個RGB分量的向量[RED GREEN BLUE]。每個組件的值必須在0.0到1.0之間。例如，矢量[1 0 1]代表洋紅色。</p>